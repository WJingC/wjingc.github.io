<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于JavaScript]]></title>
    <url>%2F2020%2F08%2F01%2FFirstJS%2F</url>
    <content type="text"><![CDATA[JavaScript基础HTML和CSS 京东 网页、网站和应用程序网页：单独的一个页面网站：一些列相关的页面组成到一起应用程序：可以和用户产生交互，并实现某种功能。 演示JavaScript的强大http://impress.github.io/impress.js/http://naotu.baidu.com/https://codecombat.com/https://ide.codemao.cn/ 需要翻墙https://developers.google.com/blockly/blockly迷宫https://blockly-games.appspot.com blockly迷宫不需要翻墙https://blockly.uieee.com/ JavaScript介绍JavaScript是什么HTML CSS JavaScript 编程语言 流程控制 Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。Java和JavaScript的关系就像张雨和张雨生的关系，只是名字很像。 ​ Java 服务器端的编程语言 ​ JavaScript 运行在客户端(浏览器)的编程语言 JavaScript是一种运行在客户端 的脚本语言JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 JavaScript最初的目的演示：http://baixiu.uieee.com/admin/login.php最初的目的是为了处理表单的验证操作。 JavaScript现在的意义(应用场景)JavaScript 发展到现在几乎无所不能。 网页特效 服务端开发(Node.js) 命令行工具(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) JavaScript和HTML、CSS的区别 HTML：提供网页的结构，提供网页中的内容 CSS: 用来美化网页 JavaScript: 可以用来控制网页内容，给网页增加动态的效果 JavaScript的组成 ECMAScript - JavaScript的核心ECMA 欧洲计算机制造联合会 网景：JavaScript 微软：JScript 定义了JavaScript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 JavaScript初体验CSS：行内样式、嵌入样式、外部样式 JavaScript的书写位置 写在行内 &lt;input type="button" value="按钮" onclick="alert('Hello World')" /> 写在script标签中 &lt;head> &lt;script> alert('Hello World!'); &lt;/script> &lt;/head> 写在外部js文件中，在页面引入 &lt;script src="main.js">&lt;/script> 注意点 引用外部js文件的script标签中不可以写JavaScript代码 计算机组成软件 应用软件：浏览器(Chrome/IE/Firefox)、QQ、Sublime、Word 系统软件：Windows、Linux、mac OSX 硬件 三大件：CPU、内存、硬盘 – 主板 输入设备：鼠标、键盘、手写板、摄像头等 输出设备：显示器、打印机、投影仪等 变量什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 var age; 变量的赋值 var age; age = 18; 同时声明多个变量 var age, name, sex; age = 10; name = 'zs'; 同时声明多个变量并赋值 var age = 10, name = 'zs'; 变量在内存中的存储var age = 18; 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 下面哪些变量名不合法 a 1 age18 18age name $name _sex &amp;sex theworld theWorld 案例 交换两个变量的值 不使用临时变量，交换两个数值变量的值 数据类型简单数据类型Number、String、Boolean、Undefined、Null Number类型 数值字面量：数值的固定值的表示法 110 1024 60.5 进制 十进制 var num = 9; 进行算数计算时，八进制和十六进制表示的数值最终都将被转换成十进制数值。 十六进制 var num = 0xA; 数字序列范围：0~9以及A~F 八进制 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 数字序列范围：0~7 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析 浮点数 浮点数的精度问题 浮点数 var n = 5e-324; // 科学计数法 5乘以10的-324次方 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); 不要判断两个浮点数是否相等 数值范围 最小值：Number.MIN_VALUE，这个值为： 5e-324 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 无穷大：Infinity 无穷小：-Infinity 数值判断 NaN：not a number NaN 与任何值都不相等，包括他本身 isNaN: is not a number String类型‘abc’ “abc” 字符串字面量 ‘程序猿’，’程序媛’, “黑马程序猿” 思考：如何打印以下字符串。 我是一个”正直”的人 我很喜欢”黑马’程序猿’” 转义符 字符串长度 length属性用来获取字符串的长度 var str = '黑马程序猿 Hello World'; console.log(str.length); 字符串拼接 字符串拼接使用 + 连接 console.log(11 + 11); console.log('hello' + ' world'); console.log('100' + '100'); console.log('11' + 11); console.log('male:' + true); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 Boolean类型 Boolean字面量： true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 复杂数据类型​ Object 获取变量的类型typeof var age = 18; console.log(typeof age); // 'number' 字面量在源代码中一个固定值的表示法。 数值字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 注释单行注释用来描述下面一个或多行代码的作用 // 这是一个变量 var name = 'hm'; 多行注释用来注释多条代码 /* var age = 18; var name = 'zs'; console.log(name, age); */ 数据类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() var num = 5; console.log(num.toString()); String() String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() var num1 = parseInt("12.3abc"); // 返回12，如果第一个字符是数字会解析知道遇到非数字结束 var num2 = parseInt("abc123"); // 返回NaN，如果第一个字符不是数字或者符号就返回NaN parseFloat() parseFloat()把字符串转换成浮点数 parseFloat()和parseInt非常相似，不同之处在与 parseFloat会解析第一个. 遇到第二个.或者非数字结束 如果解析的内容里只有整数，解析成整数 +，-0等运算 var str = '500'; console.log(+str); // 取正 console.log(-str); // 取负 console.log(str - 0); 转换成布尔类型 Boolean() 0 ‘’(空字符串) null undefined NaN 会转换成false 其它都会转换成true 操作符运算符 operator 5 + 6 表达式 组成 操作数和操作符，会有一个结果 算术运算符+ - * / % 一元运算符一元运算符：只有一个操作数的运算符 5 + 6 两个操作数的运算符 二元运算符 ++ 自身加1 – 自身减1 前置++ var num1 = 5; ++ num1; var num2 = 6; console.log(num1 + ++ num2); 后置++ var num1 = 5; num1 ++; var num2 = 6 console.log(num1 + num2 ++); 猜猜看 var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 逻辑运算符(布尔运算符)&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false || 或 两个操作数有一个为true，结果为true，否则为false ! 非 取反 关系运算符(比较运算符)&lt; &gt; &gt;= &lt;= == != === !== ==与===的区别：==只进行值得比较，===类型和值同时相等，则相等 var result = '55' == 55; // true var result = '55' === 55; // false 值相等，类型不相等 var result = 55 === 55; // true 赋值运算符= += -= *= /= %= 例如： var num = 0; num += 5; //相当于 num = num + 5; 运算符的优先级优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 // 练习1： 4 >= 6 || '人' != '阿凡达' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true // 练习2： var num = 10; 5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22' 表达式和语句表达式 一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。 语句 语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句 流程控制 程序的三种基本结构 顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下顺序执行的 分支结构根据不同的情况，执行对应代码 循环结构循环结构：重复做一件事情 分支结构if语句语法结构 if (/* 条件表达式 */) { // 执行语句 } if (/* 条件表达式 */){ // 成立执行语句 } else { // 否则执行语句 } if (/* 条件1 */){ // 成立执行语句 } else if (/* 条件2 */){ // 成立执行语句 } else if (/* 条件3 */){ // 成立执行语句 } else { // 最后默认执行语句 } 案例： 求两个数的最大数 判断一个数是偶数还是奇数 分数转换，把百分制转换成ABCDE &lt;60 E 60-70 D 70-80 C 80-90 B 90 - 100 A作业： 判断一个年份是闰年还是平年 闰年：能被4整除，但不能被100整除的年份 或者 能被400整除的年份 判断一个人的年龄是否满18岁(是否成年) 三元运算符表达式1 ? 表达式2 : 表达式3 是对if……else语句的一种简化写法 案例： 是否年满18岁 从两个数中找最大值 switch语句语法格式: switch (expression) { case 常量1: 语句; break; case 常量2: 语句; break; case 常量3: 语句; break; … case 常量n: 语句; break; default: 语句; break; } break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&#39;10&#39; 不等于数值 10） 案例： 显示星期几 素质教育（把分数变成ABCDE）千万不要写100个case哟 布尔类型的隐式转换流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined // 结果是什么？ var a = !!'123'; 案例var message; // 会自动把message转换成false if (message) { // todo... } 循环结构 在javascript中，循环语句有三种，while、do..while、for循环。 while语句基本语法： // 当循环条件为true时，执行循环体， // 当循环条件为false时，结束循环。 while (循环条件) { //循环体 } 代码示例： // 计算1-100之间所有数的和 // 初始化变量 var i = 1; var sum = 0; // 判断条件 while (i &lt;= 100) { // 循环体 sum += i; // 自增 i++; } console.log(sum); 案例： 打印100以内 7的倍数 打印100以内所有偶数 打印100以内所有偶数的和作业： 打印100以内的奇数 打印100以内的奇数的和 do…while语句 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： do { // 循环体; } while (循环条件); 代码示例： // 初始化变量 var i = 1; var sum = 0; do { sum += i;//循环体 i++;//自增 } while (i &lt;= 100);//循环条件 案例： 求100以内所有3的倍数的和 使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):&quot;，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 for语句 while和do…while一般用来解决无法确认次数的循环。for循环一般在循环次数确定的时候比较方便 for循环语法： // for循环的表达式之间用的是;号分隔的，千万不要写成, for (初始化表达式1; 判断表达式2; 自增表达式3) { // 循环体4 } 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化表达式 判断表达式 自增表达式 循环体 案例： 打印1-100之间所有数 求1-100之间所有数的和 求1-100之间所有数的平均值 求1-100之间所有偶数的和 同时求1-100之间所有偶数和奇数的和 打印正方形 // 使用拼字符串的方法的原因 // console.log 输出重复内容的问题 // console.log 默认输出内容介绍后有换行 var start = &#39;&#39;; for (var i = 0; i &lt; 10; i++) { for (var j = 0; j &lt; 10; j++) { start += &#39;* &#39;; } start += &#39;\n&#39;; } console.log(start); 打印直角三角形 var start = &#39;&#39;; for (var i = 0; i &lt; 10; i++) { for (var j = i; j &lt; 10; j++) { start += &#39;* &#39;; } start += &#39;\n&#39;; } console.log(start); 打印9*9乘法表 var str = &#39;&#39;; for (var i = 1; i &lt;= 9; i++) { for (var j = i; j &lt;=9; j++) { str += i + &#39; * &#39; + j + &#39; = &#39; + i * j + &#39;\t&#39;; } str += &#39;\n&#39;; } console.log(str); 作业： 求1-100之间所有数的乘积 求1-100之间所有奇数的和 计算1-100之间能3整除的数的和 计算1-100之间不能被7整除的数的和 // 讲解思路。如果不会写程序，可以先把数学公式准备好 本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？ 有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21） continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 案例： 求整数1～100的累加值，但要求碰到个位为3的数则停止累加 求整数1～100的累加值，但要求跳过所有个位为3的数 作业： 求1-100之间不能被7整除的整数的和（用continue）求200-300之间所有的奇数的和（用continue）求200-300之间第一个能被7整数的数（break） 调试 过去调试JavaScript的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤 浏览器中按F12-->sources-->找到需要调试的文件-->在程序的某一行设置断点 调试中的相关操作 Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。 F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。 F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips: 监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。 数组为什么要学习数组 之前学习的数据类型，只能存储一个值(比如：Number/String。我们想存储班级中所有学生的姓名，此时该如何存储？ 数组的概念 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组的定义 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。 通过数组字面量创建数组 // 创建一个空数组 var arr1 = []; // 创建一个包含3个数值的数组，多个数组项以逗号隔开 var arr2 = [1, 3, 4]; // 创建一个包含2个字符串的数组 var arr3 = ['a', 'c']; // 可以通过数组的length属性获取数组的长度 console.log(arr3.length); // 可以设置length属性改变数组中元素的个数 arr3.length = 0; 获取数组元素数组的取值 // 格式：数组名[下标] 下标又称索引 // 功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。 var arr = ['red',, 'green', 'blue']; arr[0]; // red arr[2]; // blue arr[3]; // 这个数组的最大下标为2,因此返回undefined 遍历数组 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： for(var i = 0; i &lt; arr.length; i++) { // 数组遍历的固定结构 } 数组中新增元素数组的赋值 // 格式：数组名[下标/索引] = 值; // 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。 var arr = ["red", "green", "blue"]; // 把red替换成了yellow arr[0] = "yellow"; // 给数组新增加了一个pink的值 arr[3] = "pink"; 案例求一组数中的所有数的和和平均值 求一组数中的最大值和最小值，以及所在位置 将字符串数组用|或其他符号分割 要求将数组中的0项去掉，将不为0的值存入一个新的数组，生成新的数组 翻转数组 冒泡排序，从小到大 函数为什么要有函数 如果要在多个地方求1-100之间所有数的和，应该怎么做？ 什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名），在后续开发中可以反复调用 函数的作用就是封装一段代码，将来可以重复使用 函数的定义 函数声明 function 函数名(){ // 函数体 } 函数表达式 var fn = function() { // 函数体 } 特点： 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 tellStory sayHello等 函数的调用 调用函数的语法： 函数名(); 特点： 函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： // 声明函数 function sayHi() { console.log("吃了没？"); } // 调用函数 sayHi(); // 求1-100之间所有数的和 function getSum() { var sum = 0; for (var i = 0; i &lt; 100; i++) { sum += i; } console.log(sum); } // 调用 getSum(); 函数的参数 为什么要有参数 function getSum() { var sum = 0; for (var i = 1; i &lt;= 100; i++) { sum += i; } console.log(); } // 虽然上面代码可以重复调用，但是只能计算1-100之间的值 // 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法： // 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部 // 带参数的函数声明 function 函数名(形参1, 形参2, 形参...){ // 函数体 } // 带参数的函数调用 函数名(实参1, 实参2, 实参3); 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 var x = 5, y = 6; fn(x,y); function fn(a, b) { console.log(a + b); } //x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 案例 求1-n之间所有数的和 求n-m之间所有数额和 圆的面积 求2个数中的最大值 求3个数中的最大值 判断一个数是否是素数 函数的返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： //声明一个带返回值的函数 function 函数名(形参1, 形参2, 形参...){ //函数体 return 返回值; } //可以通过变量来接收这个返回值 var 变量 = 函数名(实参1, 实参2, 实参3); 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 返回值详解： 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 案例 求阶乘 求1!+2!+3!+….+n! 求一组数中的最大值 求一组数中的最小值 arguments的使用 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历 案例求任意个数的最大值 求任意个数的和 案例求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21... 翻转数组，返回一个新数组 对数组排序，从小到大 输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数] 输入某年某月某日，判断这一天是这一年的第几天？ 函数其它匿名函数 匿名函数：没有名字的函数 匿名函数如何使用： 将匿名函数赋值给一个变量，这样就可以通过变量进行调用 匿名函数自调用 关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。 自调用函数 匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行 (function () { alert(123); })(); 函数是一种数据类型function fn() {} console.log(typeof fn); 函数作为参数 因为函数也是一种类型，可以把函数作为两一个函数的参数，在两一个函数中调用 函数做为返回值 因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回，这种用法在后面很常见。 function fn(b) { var a = 10; return function () { alert(a+b); } } fn(15)(); 代码规范1.命名规范 2.变量规范 var name = &#39;zs&#39;; 3.注释规范 // 这里是注释 4.空格规范 5.换行规范 var arr = [1, 2, 3, 4]; if (a &gt; b) { } for(var i = 0; i &lt; 10; i++) { } function fn() { } 作用域作用域：变量可以起作用的范围 全局变量和局部变量 全局变量 在任何地方都可以访问到的变量就是全局变量，对应全局作用域 局部变量 只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域) 不使用var声明的变量是全局变量，不推荐使用。 变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 块级作用域任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为JavaScript没有块级作用域 词法作用域变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 var num = 123; function foo() { console.log( num ); } foo(); if ( false ) { var num = 123; } console.log( num ); // undefiend 作用域链只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 // 案例1： function f1() { function f2() { } } var num = 456; function f3() { function f4() { } } // 案例2 function f1() { var num = 123; function f2() { console.log( num ); } f2(); } var num = 456; f1(); 预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，在提升function JavaScript的执行过程 var a = 25; function abc (){ alert(a);//undefined var a = 10; } abc(); // 如果变量和函数同名的话，函数优先 console.log(a); function a() { console.log('aaaaa'); } var a = 1; console.log(a); 全局解析规则函数内部解析规则变量提升 变量提升 定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升 JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面 // 1、----------------------------------- var num = 10; fun(); function fun() { console.log(num); var num = 20; } //2、----------------------------------- var a = 18; f1(); function f1() { var b = 9; console.log(a); console.log(b); var a = '123'; } // 3、----------------------------------- f1(); console.log(c); console.log(b); console.log(a); function f1() { var a = b = c = 9; console.log(a); console.log(b); console.log(c); } 对象为什么要有对象function printPerson(name, age, sex....) { } // 函数的参数如果特别多的话，可以使用对象简化 function printPerson(person) { console.log(person.name); …… } 什么是对象现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。 举例： 一部车，一个手机 车是一类事物，门口停的那辆车才是对象 特征：红色、四个轮子 行为：驾驶、刹车 JavaScript中的对象JavaScript中的对象其实就是生活中对象的一个抽象 JavaScript的对象是无序属性的集合。 其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。 对象的行为和特征 特征---属性 行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 对象字面量 字面量：11 ‘abc’ true [] {}等 var o = { name: 'zs, age: 18, sex: true, sayHi: function () { console.log(this.name); } }; 思考： 如何把学生对象、老师对象、英雄对象改写成字面量的方式 对象创建方式 对象字面量 var o = { name: 'zs', age: 18, sex: true, sayHi: function () { console.log(this.name); } }; new Object()创建对象 var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function(){ console.log('Hello,everyBody'); } 工厂函数创建对象function createPerson(name, age, job) { var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function(){ console.log('Hello,everyBody'); } return person; } var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数function Person(name,age,job){ this.name = name; this.age = age; this.job = job; this.sayHi = function(){ console.log('Hello,everyBody'); } } var p1 = new Person('张三', 22, 'actor'); 属性和方法 如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 new会在内存中创建一个新的空对象 new 会让this指向这个新的对象 执行构造函数 目的：给这个新对象加属性和方法 new会返回这个新对象 this详解JavaScript中的this指向问题，有时候会让人难以捉摸，随着学习的深入，我们可以逐渐了解 现在我们需要掌握函数内部的this几个特点 1. 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 2. 一般函数直接执行，内部this指向全局window 3. 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 4. 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化 对象的使用遍历对象的属性 通过for..in语法可以遍历一个对象 var obj = {}; for (var i = 0; i &lt; 10; i++) { obj[i] = i * 2; } for(var key in obj) { console.log(key + "==" + obj[key]); } 删除对象的属性function fun() { this.name = 'mm'; } var obj = new fun(); console.log(obj.name); // mm delete obj.name; console.log(obj.name); // undefined 简单类型和复杂类型的区别 基本类型又叫做值类型，复杂类型又叫做引用类型 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。 堆和栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。 注意：JavaScript中没有堆和栈的概念，此处我们用堆和栈来讲解，目的方便理解和方便以后的学习。 基本类型在内存中的存储 复杂类型在内存中的存储 基本类型作为函数的参数 复杂类型作为函数的参数 // 下面代码输出的结果 function Person(name,age,salary) { this.name = name; this.age = age; this.salary = salary; } function f1(person) { person.name = "ls"; person = new Person("aa",18,10); } var p = new Person("zs",18,1000); console.log(p.name); f1(p); console.log(p.name); 思考： //1. var num1 = 10; var num2 = num1; num1 = 20; console.log(num1); console.log(num2); //2. var num = 50; function f1(num) { num = 60; console.log(num); } f1(num); console.log(num); //3. var num1 = 55; var num2 = 66; function f1(num, num1) { num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2); } f1(num1, num2); console.log(num1); console.log(num2); console.log(num); 内置对象JavaScript中的对象分为3种：内置对象、浏览器对象、自定义对象 JavaScript 提供多个内置对象：Math/Array/Number/String/Boolean… 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN/W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 MDNMozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN 通过查询MDN学习Math对象的random()方法的使用 如何学习一个方法？ 方法的功能 参数的意义和类型 返回值意义和类型 demo进行测试 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() Math.PI // 圆周率 Math.random() // 生成随机数 Math.floor()/Math.ceil() // 向下取整/向上取整 Math.round() // 取整，四舍五入 Math.abs() // 绝对值 Math.max()/Math.min() // 求最大和最小值 Math.sin()/Math.cos() // 正弦/余弦 Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例 求10-20之间的随机数 随机生成颜色RGB 模拟实现max()/min() Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 // 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数 var now = new Date(); console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数 Date构造函数的参数 1. 毫秒数 1498099000356 new Date(1498099000356) 2. 日期格式字符串 '2015-5-1' new Date('2015-5-1') 3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 var now = new Date(); // valueOf用于获取对象的原始值 console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题 var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式 var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 toString() // 转换成字符串 valueOf() // 获取毫秒值 // 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用 toDateString() toTimeString() toLocaleDateString() toLocaleTimeString() 获取日期指定部分 getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime() getMilliseconds() getSeconds() // 返回0-59 getMinutes() // 返回0-59 getHours() // 返回0-23 getDay() // 返回星期几 0周日 6周6 getDate() // 返回当前月的第几天 getMonth() // 返回月份，***从0开始*** getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 function formatDate(d) { //如果date不是日期对象，返回 if (!date instanceof Date) { return; } var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second; } 计算时间差，返回相差的天/时/分/秒 function getInterval(start, end) { var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return { day: day, hour: hour, minute: minute, second: second } } Array对象 创建数组对象的两种方式 字面量方式 new Array() // 1. 使用构造函数创建数组对象 // 创建了一个空数组 var arr = new Array(); // 创建了一个数组，里面存放了3个字符串 var arr = new Array('zs', 'ls', 'ww'); // 创建了一个数组，里面存放了4个数字 var arr = new Array(1, 2, 3, 4); // 2. 使用字面量创建数组对象 var arr = [1, 2, 3]; // 获取数组中元素的个数 console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() // 1 栈操作(先进后出) push() pop() //取出数组中的最后一项，修改length属性 // 2 队列操作(先进先出) push() shift() //取出数组中的第一个元素，修改length属性 unshift() //在数组最前面插入项，返回数组的长度 // 3 排序方法 reverse() //翻转数组 sort(); //即使是数组sort也是根据字符，从小到大排序 // 带参数的sort是如何实现的？ // 4 操作方法 concat() //把参数拼接到当前数组 slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始 splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目) // 5 位置方法 indexOf()、lastIndexOf() //如果没找到返回-1 // 6 迭代方法 不会修改原数组(可选) every()、filter()、forEach()、map()、some() // 7 方法将数组的所有元素连接到一个字符串中。 join() 清空数组 // 方式1 推荐 arr = []; // 方式2 arr.length = 0; // 方式3 arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 function myJoin(array, seperator) { seperator = seperator || ','; array = array || []; if (array.length == 0){ return ''; } var str = array[0]; for (var i = 1; i &lt; array.length; i++) { str += seperator + array[i]; } return str; } var array = [6, 3, 5, 6, 7, 8, 0]; console.log(myJoin(array, '-')); console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 function myReverse(arr) { if (!arr || arr.length == 0) { return []; } for (var i = 0; i &lt; arr.length / 2; i++) { var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; } return arr; } var array = ['a', 'b', 'c']; console.log(myReverse(array)); console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 // 方式1 var array = [1500,1200,2000,2100,1800]; var tmpArray = []; for (var i = 0; i &lt; array.length; i++) { if(array[i] &lt; 2000) { tmpArray.push(array[i]); } } console.log(tmpArray); // 方式2 var array = [1500, 1200, 2000, 2100, 1800]; array = array.filter(function (item, index) { if (item &lt; 2000) { return true; } return false; }); console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 var array = ['c', 'a', 'z', 'a', 'x', 'a']; do { var index = array.indexOf('a',index + 1); if (index != -1){ console.log(index); } } while (index > 0); 编写一个方法去掉一个数组的重复元素 var array = ['c', 'a', 'z', 'a', 'x', 'a']; function clear() { var o = {}; for (var i = 0; i &lt; array.length; i++) { var item = array[i]; if (o[item]) { o[item]++; }else{ o[item] = 1; } } var tmpArray = []; for(var key in o) { if (o[key] == 1) { tmpArray.push(key); }else{ if(tmpArray.indexOf(key) == -1){ tmpArray.push(key); } } } returm tmpArray; } console.log(clear(array)); 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean // 下面代码的问题？ // s1是基本类型，基本类型是没有方法的 var s1 = 'zhangsan'; var s2 = s1.substring(5); // 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于： var s1 = new String('zhangsan'); var s2 = s1.substring(5); s1 = null; // 创建基本包装类型的对象 var num = 18; //数值，基本类型 var num = Number('18'); //类型转换 var num = new Number(18); //基本包装类型，对象 // Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如： var b1 = new Boolean(false); var b2 = b1 &amp;&amp; true; // 结果是什么 String对象 字符串的不可变 var str = 'abc'; str = 'hello'; // 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中 // 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变 // 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 var str = new String('Hello World'); // 获取字符串中字符的个数 console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 // 1 字符方法 charAt() //获取指定位置处字符 charCodeAt() //获取指定位置处字符的ASCII码 str[0] //HTML5，IE8+支持 和charAt()等效 // 2 字符串操作方法 concat() //拼接字符串，等效于+，+更常用 slice() //从start位置开始，截取到end位置，end取不到 substring() //从start位置开始，截取到end位置，end取不到 substr() //从start位置开始，截取length个字符 // 3 位置方法 indexOf() //返回指定内容在元字符串中的位置 lastIndexOf() //从后往前找，只找第一个匹配的 // 4 去除空白 trim() //只能去除字符串前后的空白 // 5 大小写转换方法 to(Locale)UpperCase() //转换大写 to(Locale)LowerCase() //转换小写 // 6 其它 search() replace() split() fromCharCode() // String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” var s = "我爱中华人民共和国"; s = s.substr(2,2); console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 var s = 'abcoefoxyozzopp'; var array = []; do { var index = s.indexOf('o', index + 1); if (index != -1) { array.push(index); } } while (index > -1); console.log(array); 把字符串中所有的o替换成! var s = 'abcoefoxyozzopp'; do { s = s.replace('o', ''); } while (s.indexOf('o') > -1); console.log(s); console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 var s = 'abcoefoxyozzopp'; var o = {}; for (var i = 0; i &lt; s.length; i++) { var item = s.charAt(i); if (o[item]) { o[item] ++; }else{ o[item] = 1; } } var max = 0; var char ; for(var key in o) { if (max &lt; o[key]) { max = o[key]; char = key; } } console.log(max); console.log(char);]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS]]></title>
    <url>%2F2020%2F07%2F01%2FFirstCSS%2F</url>
    <content type="text"><![CDATA[CSS的发展历程从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。 CSS 网页的美容师CSS的出现，拯救了混乱的HTML，当让更加拯救了我们web开发者。 让我们的网页更加丰富多彩。 CSS的最大贡献就是： 让 HTML 从样式中解脱苦海， 实现了 HTML 专注去做 结构呈现。 而样式交给 CSS 后，你完全可以放心的早点洗洗睡了！ 而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师，不信，你看: ps: 你跟Angelababy只差了一个妆容的距离 来个更直观的认识吧： 有人说， 没有不漂亮的女人，只有不会打扮的女人。 我想说， 没有不好看的网页，只有不会CSS的前端。 网页添加 CSS和不添加CSS 的对比： 带有CSS的页面 没有CSS的页面 CSS初识CSS(Cascading Style Sheets) CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 在上面的样式规则中: 1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。 2.属性和属性值以“键值对”的形式出现。 3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。 4.属性和属性值之间用英文“:”连接。 5.多个“键值对”之间用英文“;”进行区分。 可以用段落 和 表格的对齐的演示。 CSS字体样式属性font-size:字号大小font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下： font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码： p{ font-family:”微软雅黑”;} 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 常用技巧： 1. 现在网页中普遍使用14px+。 2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。 3. 各种字体之间必须使用英文状态下的逗号隔开。 4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。 5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。 6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65B0\5B8B\4F53 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 楷体_GB2312 KaiTi_GB2312 \6977\4F53_GB2312 隶书 LiSu \96B6\4E66 幼园 YouYuan \5E7C\5706 华文细黑 STXihei \534E\6587\7EC6\9ED1 细明体 MingLiU \7EC6\660E\4F53 新细明体 PMingLiU \65B0\7EC6\660E\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 小技巧： 数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 小技巧： 平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置，其基本语法格式如下： 选择器{font: font-style font-weight font-size/line-height font-family;} 使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—查看 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 选择器（重点）要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。 如上图所以，要把里面的小黄人分为2组，最快的方法怎办？ 很多， 比如 一只眼睛的一组，剩下的一组 这就用到基础选择器组： 标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 或者 元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 课堂案例： 传智简介 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： .类名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签调用的时候用 class=“类名” 即可。 类选择器最大的优势是可以为元素对象定义单独或相同的样式。 小技巧： 1.长名称或词组可以使用中横线来为选择器命名。 2.不建议使用“_”下划线来命名CSS选择器。 ​ 输入的时候少按一个shift键; 浏览器兼容问题 (比如使用tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“”) 3.不要纯数字、中文等命名， 尽量使用英文字母来表示。 猜谜底游戏： 你猜？ 命名规范： 见附件（Web前端开发规范手册.doc） 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 课堂案例： &lt;head> &lt;meta charset="utf-8"> &lt;style> span { font-size: 100px; } .blue { color: blue; } .red { color: red; } .orange { color: orange; } .green { color: green; } &lt;/style> &lt;/head> &lt;body> &lt;span class="blue">G&lt;/span> &lt;span class="red">o&lt;/span> &lt;span class="orange">o&lt;/span> &lt;span class="blue">g&lt;/span> &lt;span class="green">l&lt;/span> &lt;span class="red">e&lt;/span> &lt;/body> 多类名选择器我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 1. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。 2. 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 &lt;div class="pink fontWeight font20">亚瑟&lt;/div> &lt;div class="font20">刘备&lt;/div> &lt;div class="font14 pink">安其拉&lt;/div> &lt;div class="font14">貂蝉&lt;/div> id选择器id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下： #id名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 通配符选择器通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下： * { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 * { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/ } 注意： 这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo {} 而我们的伪类 用 2个点 就是 冒号 比如 :link{} 链接伪类选择器 :link / 未访问的链接 / :visited / 已访问的链接 / :hover / 鼠标移动到链接上 / :active / 选定的链接 / 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao a { /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray; } a:hover { /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */ } 结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 li:first-child { /* 选择第一个孩子 */ color: pink; } li:last-child { /* 最后一个孩子 */ color: purple; } li:nth-child(4) { /* 选择第4个孩子 n 代表 第几个的意思 */ color: skyblue; } 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 :target { color: red; font-size: 30px; } CSS注释CSS规则是使用 /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。 例如： p { font-size: 14px; /* 所有的字体是14像素大小*/ } CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 letter-spacing:字间距letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing:单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 颜色半透明(css3)文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下： color: rgba(r,g,b,a) a 是alpha 透明的意思 取值范围 0~1之间 color: rgba(0,0,0,0.3) 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 前两项是必须写的。 后两项可以选写。 sublime快捷方式sublime可以快速提高我们代码的书写方式 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 就可以了 比如 div3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 引入CSS样式表（书写位置）CSS可以写到那个位置？ 是不是一定写到html文件里面呢？ 行内式（内联样式）是通过标签的style属性来设置元素的样式，其基本语法格式如下： &lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。 内部样式表（内嵌式）内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： &lt;head> &lt;style type="text/CSS"> 选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;} &lt;/style> &lt;/head> 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： &lt;head> &lt;link href="CSS文件的路径" type="text/CSS" rel="stylesheet" /> &lt;/head> 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。 rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内嵌样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 标签显示模式（display） 非洲黑人： 皮肤内黑色素含量高，以吸收阳光中的紫外线，保护皮肤内部结构免遭损害，头发象羊毛一样卷曲，使每根卷发周围都有许多空隙，空隙充满空气，卷发有隔热作用。 欧洲白人： 生活寒带或着是说常年温度较低的地缘,加上年日照时间少，身体的黑色素沉淀比较少所以出现皮肤、发色、瞳晕都呈现浅色 传智黄人： 我中间的。。。 最重要的总结： 是为了更好的适应环境而完成的自然选择。 同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(显示模式) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 我一样重要 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。 （2）默认宽度就是它本身内容的宽度。 （3）高度，行高、外边距以及内边距都可以控制。 三者的 形状 显示模式 形状 图片 块级元素 面包 行内元素 牛奶 行内块元素 果冻 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 他和他，在一起， 在一起 一起的意思 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。 白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 比如： .demo &gt; h3 {color: red;} 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 测试题&lt;div class="nav"> &lt;!-- 主导航栏 --> &lt;ul> &lt;li>公司首页&lt;/li> &lt;li>公司简介&lt;/li> &lt;li>公司产品&lt;/li> &lt;li>联系我们&lt;/li> &lt;/ul> &lt;div> 收藏本站 &lt;/div> &lt;/div> &lt;div class="sitenav"> &lt;!-- 侧导航栏 --> &lt;div class="site-l">左侧侧导航栏&lt;/div> &lt;div class="site-r">&lt;a href="#">登录&lt;/a>&lt;/div> &lt;/div> 在不修改以上代码的前提下，完成以下任务： 链接 登录 的颜色为红色。 主导航栏里面的文字颜色为绿色。 主导航栏和侧导航栏里面文字都是16像素并且是微软雅黑。 收藏本站 要求字体加粗。 属性选择器 **选择器 **示例 **含义 E[attr]** 存在attr属性即可 E[attr=val]** 属性值完全等于val E[attr*=val]** 属性值里包含val字符并且在“任意”位置 E[attr^=val]** 属性值里包含val字符并且在“开始”位置 E[attr$=val]** 属性值里包含val字符并且在“结束”位置 /* 获取到 拥有 该属性的元素 */ li[type] { border: 1px solid gray; } /* 获取 属性等于某个值的 元素 属性值 可以使用 引号进行包裹 */ li[type="vegetable"] { background-color: green; } /* 使用空格分隔的 多个属性 其中有某个属性即可获取 */ li[type~="hot"] { font-size: 40px; } /* 获取以某个属性开头的语法 */ li[color^='green'] { background-color: orange; } /* 获取以某个值 结尾的属性 */ li[type$='t']{ color: hotpink; font-weight: 900; } /* 获取 属性中 拥有某个值的 元素 */ li[type*=ea] { font-size: 100px; } /* 如果属性的值 只有very 也能够获取 用来获取 多个属性 并且 使用-连接 */ li[price|='very'] { background-color: darkred; } &lt;ul> &lt;li type='fruit' color='green'>西瓜&lt;/li> &lt;li type='vegetable' color='greenyellow'>西兰花&lt;/li> &lt;li type='meat'>牛肉&lt;/li> &lt;li type='meat hot'>猪肉&lt;/li> &lt;li type='drink hot'>可乐&lt;/li> &lt;li type='drink hot'>雪碧&lt;/li> &lt;li price='very-cheap'>红酒&lt;/li> &lt;li price='very'>白酒&lt;/li> &lt;/ul> 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； p::first-letter { font-size: 20px; color: hotpink; } /* 首行特殊样式 */ p::first-line { color: skyblue; } p::selection { /* font-size: 50px; */ color: orange; } 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 div::befor { content:"开始"; } div::after { content:"结束"; } E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解 “:” 与 “::” 区别在于区分伪类和伪元素 CSS 背景(background)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： background-image : none | url (url) 参数： none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像 background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat）语法： background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数： repeat : 背景图像在纵向和横向上平铺（默认的） no-repeat : 背景图像不平铺 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 背景位置(position)语法： background-position : length || length background-position : position || position 参数： length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明： 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着语法： background-attachment : scroll | fixed 参数： scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明： 设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。 同样， 可以给 文字和边框透明 都是 rgba 的格式来写。 color:rgba(0,0,0,0.3); border: 1px solid rgba(0,0,0,0.3); 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高） b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。 c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 background-image: url('images/gyt.jpg'); background-size: 300px 100px; /* background-size: contain; */ /* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 background-image: url('images/gyt.jpg'),url('images/robot.png'); CSS 三大特性层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。 CSS层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 CSS最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 CSS最后的执行口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性） CSS优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。 在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。 行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。 权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。 CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 比如的例子： div ul li ------&gt; 0,0,0,3 .nav ul li ------&gt; 0,0,1,2 a:hover -----—&gt; 0,0,1,1 .nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 ​ 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 总结优先级： 使用了 !important声明的规则。 内嵌在 HTML 元素的 style属性里面的声明。 使用了 ID 选择器的规则。 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 使用了元素选择器的规则。 只包含一个通用选择器的规则。 总结：权重是优先级的算法，层叠是优先级的表现 盒子模型（CSS重点）其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。 所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 牛奶是怎样运输，让消费者购买的呢？ 我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。 看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。 CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 CSS3的 盒子模型 我们后面会讲。 首先，我们来看一张图，来体会下什么是盒子模型。 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。 语法： border : border-width || border-style || border-color 边框属性—设置边框样式（border-style） 边框样式用于定义页面中边框的风格，常用属性值如下： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 double：边框为双实线 表格的细线边框以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。 table{ border-collapse:collapse; } border-collapse:collapse; 表示边框合并在一起。 盒子边框总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 圆角边框(CSS3)从此以后，我们的世界不只有矩形。 语法格式： Border-radius: 水平半径/垂直半径； 一般我们垂直半径都是省略的默认和水平半径一样。 border-radius: 左上角 右上角 右下角 左下角; 课堂案例: &lt;style> div { width:200px; height:200px; border:1px solid red; margin:10px 40px; text-align: center; line-height: 200px; } div:first-child { border:10px solid red; border-radius: 20px/50px; } div:nth-child(2) { border-radius: 20px; } div:nth-child(3) { border-radius: 15px 0; } div:nth-child(4) { border-radius:100px; } div:nth-child(5) { border-radius: 50%; } div:nth-child(6) { border-radius: 100px 0; } div:nth-child(7) { border-radius: 200px 0 0 0; } div:nth-child(8) { border-radius: 100px 100px 0 0; height:100px; /*高度减半*/ } div:nth-child(9) { border-radius: 100px; height:100px; } div:nth-child(10) { border-radius: 100%; height:100px; } &lt;/style 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 panda padding-top:上内边距 padding-right:右内边距 padding-bottom:下内边距 padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 课堂案例： 新浪导航 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。 margin-top:上外边距 margin-right:右外边距 margin-bottom:下外边距 margin-left:上外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： .header{ width:960px; margin:0 auto;} 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： * { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */ } 注意： 行内元素是只有左右内外边距的，是没有上下内外边距的。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。 待续。。。。 content宽度和高度使用宽度属性width和高度属性height可以对盒子的大小进行控制。 width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 盒子的总宽度= width+左右内边距之和+左右边框宽度之和+左右外边距之和 盒子的总高度= height+上下内边距之和+上下边框宽度之和+上下外边距之和 注意： 1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 三个计算题1. .demo{width:200px;height:200px;border:1px solid red; padding:20px;}， 盒子最终占有的空间是多大？ 2. 一个盒子需要占用的空间是 400像素， 但是盒子又有 padding:25px, border: 1px solid red; 问，我们需要改动盒子宽度为多少？ 3. 如何让一个200 * 200像素的盒子， 在一个400 * 400的盒子里面水平居中，垂直居中。 盒子模型布局稳定性开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？ 答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: border-box 盒子大小为 width 2、box-sizing: content-box 盒子大小为 width + padding + border 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 div { width: 100px; height: 100px; background: skyblue; margin: 0 auto; border: 1px solid gray; /* 默认的设置 如果我们添加了 border属性 该容器的大小会发生改变 因为他要优先保证内部的内容所占区域 不变 */ /* box-sizing 如果不设置 默认的值 就是 content-box: 优先保证内容的大小 对盒子进行缩放; border-box: 让 盒子 优先保证自己所占区域的大小,对内容进行压缩; */ box-sizing: border-box; } 盒子阴影语法格式： box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset img { border:10px solid orange; box-shadow:3px 3px 5px 4px rgba(0,0,0,1); } 浮动(float)普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。 前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？ CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float)浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释） 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 选择器{float:属性值;} 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少 浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮漏特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，这是特殊的使用，有很多的不好处，使用要谨慎。 清除浮动 人生就像乘坐北京地铁一号线： 途经国贸，羡慕繁华； 途经天安门，幻想权力； 途经金融街，梦想发财； 经过公主坟，遥想华丽家族； 经过玉泉路，依然雄心勃勃… 这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！ 顿时醒悟：人生苦短，有始有终。 好比我们的浮动，有浮动开始，则就应该有浮动结束。 为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 选择器{clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”>&lt;/div>，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动使用方法： .clearfix:after { content: "."; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 使用before和after双伪元素清除浮动使用方法： .clearfix:before,.clearfix:after { content:"."; display:table; } .clearfix:after { clear:both; } .clearfix { *zoom:1; } 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML页面，CSS文件。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 Photoshop Photoshop基本使用PS界面组成：菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口​ 窗口菜单，可显示隐藏所有面板 工作区：（新建） 1、调整浮动面板 2、选项栏后方，新建工作区，命名。 删除工作区：先选择其他工作区，再操作删除工作区。 基本操作文件下拉菜单：​ 1、新建 新建文档 CTRL+N 单位：像素 厘米 毫米 屏幕显示： 单位 像素 72像素/英寸 RGB颜色模式 印刷行业： 单位 CM/MM 300像素/英寸 CMYK颜色模式 2、关闭文档 CTRL+W 3、存储 CTRL+S （替存） 4、存储为 CTRL+SHIFT+S 另存一份文件 5、格式：​ .psd PS源文件格式 图层、文字、样式等，可再次编辑​ （给自己）​ .jpg 有损压缩格式 （给客户） 品质 最高12 6、文件打开：​ 1）文件下拉菜单-打开（CTRL+O欧）（双击软件空白处=打开）​ 2）拖拽文件至选项栏上方，释放鼠标 移动工具 V1、不同文件之间拖拽图像。 图层操作 图层面板快捷键 F7 图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 3、拖拽目标至创建新图层按钮 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 图层透明度不透明度：设置图层的不透明程度 0%完全透明，不可见 ​ 100%完全不透明，真实可见 填充：与不透明度效果类似 ) 键盘数字键，可快速设置透明度数值 套索工具 L1、套索工具 L 在屏幕上拖拽鼠标左键，释放后生成选区 2、多边形套索 L 连续单击绘制多边形选区 ​ 闭合方法：1、单击起始点 2、双击任意位置 ​ DELETE删除当前点 3、磁性套索工具 L 单击颜色交界后，沿交界线拖拽鼠标，可生成选区。 磁性套索 LL 在颜色交界的位置单击后拖动。单击起始点后，生成选区。 大小写键：CAPSLOCK 可控制光标精确状态。 魔棒工具 W以单击位置为选择色，选择相似颜色生成选区。 容差：选择颜色的范围 容差小，颜色选择精确。 0-255 连续：勾选连续时，相连颜色生成选区。 ​ 不勾选，画面中所有相似颜色被选中生成选区。 按SHIFT在未生成选区位置单击，可选区相加。 选区反选：CTRL+SHIFT+I 选区布尔运算 选区面积大小的变化。 新选区：保持选中状态 添加到选区：相加运算（按住SHIFT再绘制选区） 从选区减去：相减（按住ALT再绘制选区） 与选区交叉：重合部分保留。（按住ALT+SHIFT再绘制选区） 钢笔工具： P作用：绘制路径，生成选区，抠图。 组成;路径线和锚点 绘制路径后，CTRL+回车，生成选区。 路径类型： 直线型路径：连续单击 曲线型路径：第一点单击，第二点拖动鼠标。 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 2.图层—新建基于图层的切片 利用标尺 基础参考线的切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！ 为什么要用定位？那么定位，最长运用的场景再那里呢？ 来看几幅图片，你一定会有感悟！ 第一幅图， 小黄色块可以再图片上移动： 第二幅图， 左右箭头压住图片： 第三幅图, hot 再盒子外面多出一块，更加突出： 以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！ 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 边偏移属性 描述 top 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom 底部偏移量，定义元素相对于其父元素下边线的距离 left 左侧偏移量，定义元素相对于其父元素左边线的距离 right 右侧偏移量，定义元素相对于其父元素右边线的距离 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 值 描述 static 自动定位（默认定位方式） relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元素进行定位 fixed 固定定位，相对于浏览器窗口进行定位 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 PS： 静态定位其实没啥可说的。 相对定位relative(自恋型)小笑话： 刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。 相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。 绝对定位absolute (拼爹型)小笑话： 吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt; 我一阵感动，刚想夸他两句。 儿子接着说：“以后全靠你让我拼爹了！” [注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的盒子没有边偏移如果只是给盒子指定了 定位，但是没有给与边偏移，则改盒子以标准流来显示排序，和上一个盒子的底边对齐，但是不占有位置。 子绝父相这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。 这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图： 草图就是如下： 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 如果取值相同，则根据书写顺序，后来居上。 后面数字一定不能加单位。 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后，可以不用转换模式，直接给高度和宽度就可以了。 元素的显示与隐藏在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。 他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！ display 显示display 设置或检索对象是否及如何显示。 display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 visibility 可见性设置或检索是否显示对象。 visible : 对象可视 hidden : 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 visible : 不剪切内容也不添加滚动条。 auto : 超出自动显示滚动条，不超出不显示滚动条 hidden : 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll : 不管超出内容否，总是显示滚动条 CSS高级技巧CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 cursor : default 小白 | pointer 小手 | move 移动 | text 文本 鼠标放我身上查看效果哦： &lt;ul> &lt;li style="cursor:default">我是小白&lt;/li> &lt;li style="cursor:pointer">我是小手&lt;/li> &lt;li style="cursor:move">我是移动&lt;/li> &lt;li style="cursor:text">我是文本&lt;/li> &lt;/ul> 尽量不要用hand 因为 火狐不支持 pointer ie6以上都支持的尽量用 轮廓 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; &lt;input type="text" style="outline: 0;"/> 防止拖拽文本域resizeresize：none 这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。 右下角可以拖拽： 右下角不可以拖拽： &lt;textarea style="resize: none;">&lt;/textarea> vertical-align 垂直对齐以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto; 以前我们还讲过让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。 vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。 vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片和表单等。 图片和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙有个很重要特性你要记住： 如果一个元素没有基线，比如图片或者表单等行内块元素，则他的底线会和父级盒子的基线对齐。 这样会造成一个问题，就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 CSS精灵技术（sprite）精灵技术产生的背景 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术本质简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图，如下图所示为京东网站中的一个精灵图。 精灵技术的使用CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。 制作精灵图CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。 我们精灵图的宽度取决于最宽的那个背景。 我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。 在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 字体图标图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont). 字体图标优点可以做出跟图片一样可以做的事情,改变透明度、旋转度，等.. 但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等... 本身体积更小，但携带的信息并没有削减。 几乎支持所有的浏览器 移动端设备必备良药... 字体图标使用流程总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库 IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库 http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法 第一步：引入项目下面生成的fontclass代码：&lt;link rel="stylesheet" type="text/CSS" href="./iconfont.CSS"> 第二步：挑选相应图标并获取类名，应用于页面：&lt;i class="iconfont icon-xxx">&lt;/i> 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： &lt;li> &lt;a href="#"> &lt;span>导航栏内容&lt;/span> &lt;/a> &lt;/li> 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 伸缩布局(CSS3)CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的 方向：默认主轴从左向右，侧轴默认从上到下 主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 2、各属性详解** a、flex-direction调整主轴方向（默认为水平方向） b、justify-content调整主轴对齐 c、align-items调整侧轴对齐 d、flex-wrap控制是否换行 e、align-content堆栈（由flex-wrap产生的独立行）对齐 f、flex-flow是flex-direction、flex-wrap的简写形式 g、flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 h、order控制子项目的排列顺序，正序方式排序，从小到大 此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值 过渡(CSS3)过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。 语法格式: transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 运动曲线示意图： img { width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%; transition:transform 0.5s ease-in 0s; } img:hover { transform:rotate(180deg); } 2D变形(CSS3)转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 变形转换 transform 移动 translate(x, y) translate(50px,50px); 使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 可以改变元素的位置，x、y可为负值； translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动） translateX(x)仅水平方向移动（X轴移动） translateY(Y)仅垂直方向移动（Y轴移动） .box { width: 499.9999px; height: 400px; background: pink; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); /* 走的自己的一半 */ } 让定位的盒子水平居中 缩放 scale(x, y) transform:scale(0.8,1); 可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） scaleX(x)元素仅水平方向缩放（X轴缩放） scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 旋转 rotate(deg) 可以对元素进行旋转，正值为顺时针，负值为逆时针； transform:rotate(45deg); 当元素旋转以后，坐标轴也跟着发生的转变 调整顺序可以解决，把旋转放到最后 注意单位是 deg 度数 案例旋转扑克牌 body { background-color: skyblue; } .container { width: 100px; height: 150px; border: 1px solid gray; margin: 300px auto; position: relative; } .container > img { display: block; width: 100%; height: 100%; position: absolute; transform-origin: top right; /* 添加过渡 */ transition: all 1s; } .container:hover img:nth-child(1) { transform: rotate(60deg); } .container:hover img:nth-child(2) { transform: rotate(120deg); } .container:hover img:nth-child(3) { transform: rotate(180deg); } .container:hover img:nth-child(4) { transform: rotate(240deg); } .container:hover img:nth-child(5) { transform: rotate(300deg); } .container:hover img:nth-child(6) { transform: rotate(360deg); } 倾斜 skew(deg, deg) transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 5.transform-origin可以调整元素转换的原点 div{transform-origin: left top;transform: rotate(45deg); } /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 案例： 菱形照片 三角盒子 3D变形左手坐标系 伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 rotateX() 就是沿着 x 立体旋转. img { transition:all 0.5s ease 0s; } img:hove { transform:rotateX(180deg); } rotateY()沿着y轴进行旋转 img { transition:all 0.5s ease 0s; } img:hove { transform:rotateX(180deg); } rotateZ()沿着z轴进行旋转 img { transition:all .25s ease-in 0s; } img:hover { /* transform:rotateX(180deg); */ /* transform:rotateY(180deg); */ /* transform:rotateZ(180deg); */ /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */ } 透视(perspective)电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。 注：并非任何情况下需要透视效果，根据开发需要进行设置。 perspective有两种写法 作为一个属性，设置给父元素，作用于所有3D转换的子元素 作为transform属性的一个值，做用于元素自身 理解透视距离原理： 开门案例body { } .door { width: 300px; height: 300px; margin: 100px auto; border: 1px solid gray; perspective: 1000px; background: url('images/dog.gif') no-repeat center/cover; position: relative; } .door > div { box-sizing: border-box; border: 1px solid black; } .left { float: left; width: 50%; height: 100%; background-color: brown; transform-origin: left center; transition: 1s; position: relative; } .left::before { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; right: 0px; transform: translateY(-10px); border: 1px solid whitesmoke; } .right { width: 50%; height: 100%; float: left; background-color: brown; transform-origin: right center; transition: 1s; position: relative; } .right::before { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; left: 0px; transform: translateY(-10px); border: 1px solid whitesmoke; } .door:hover .left { transform: rotateY(-130deg); } .door:hover .right { transform: rotateY(130deg); } translateX(x)仅水平方向移动**（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 3D呈现（transform-style）设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为转换原素。 flat：所有子元素在 2D 平面呈现 preserve-3d：保留3D空间 3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。 一般而言，该声明应用在3D变换的兄弟元素们的父元素上。 翻转盒子案例(百度钱包)body { margin: 0; padding: 0; background-color: #B3C04C; } .wallet { width: 300px; height: 300px; margin: 50px auto; position: relative; transform-style: preserve-3d; transition: all 0.5s; } .wallet::before, .wallet::after { content: ''; position: absolute; left: 0; top: 0; display: block; width: 100%; height: 100%; background-image: url(./images/bg.png); background-repeat: no-repeat; } .wallet::before { background-position: right top; transform: rotateY(180deg); } .wallet::after { background-position: left top; transform: translateZ(2px); } .wallet:hover { transform: rotateY(180deg); } 动画(CSS3)动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 语法格式： animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向; 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r @keyframes 动画名称 { from{ 开始位置 } 0% to{ 结束 } 100% } animation-iteration-count:infinite; 无限循环播放 animation-play-state:paused; 暂停动画&quot; 小汽车案例body { background: white; } img { width: 200px; } .animation { animation-name: goback; animation-duration: 5s; animation-timing-function: ease; animation-iteration-count: infinite; } @keyframes goback { 0%{} 49%{ transform: translateX(1000px); } 55%{ transform: translateX(1000px) rotateY(180deg); } 95%{ transform: translateX(0) rotateY(180deg); } 100%{ transform: translateX(0) rotateY(0deg); } }]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Html]]></title>
    <url>%2F2020%2F06%2F01%2FFirstHtml%2F</url>
    <content type="text"><![CDATA[认识网页网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 &lt;img src=”media/mi.png”alt=””&gt; 思考： 网页是如何形成的呢? 常见浏览器介绍浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 浏览器内核（理解）浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。 渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。 样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。 行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分 理想状态我们的源码： .HTML .css .js 专业的人，写专业的代码 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 样式标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 &lt;strong> 我是加粗的字体 &lt;/strong> 注意： 体会 文本 标签 语言 几个词语 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： &lt;HTML> &lt;head> &lt;title>&lt;/title> &lt;/head> &lt;body> &lt;/body> &lt;/HTML> 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 1 HTML标签： 作用所有HTML中标签的一个根节点。 2 head标签： 作用：用于存放： title,meta,base,style,script,link 注意在head标签中我们必须要设置的标签是title 3.title标签： 作用：让页面拥有一个属于自己的标题。 4.body标签： 作用：页面在的主体部分，用于存放所有的HTML标签： p,h,a,b,u,i,s,em,del,ins,strong,img 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 &lt;标签名> 内容 &lt;/标签名> 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 比如 &lt;body>我是文字 &lt;/body> 2.单标签 &lt;标签名 /> 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 比如 &lt;br /> HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 &lt;head> &lt;title> &lt;/title> &lt;/head> 2.并列关系 &lt;head>&lt;/head> &lt;body>&lt;/body> 测试题： 请问下列哪个标签是错误的？ A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 开发工具 这些工具你认识几个？ 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 sublime 一些常用快捷键 点我查看 再页面中输入 以下2个单词 1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;&lt;!DOCTYPE html> 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 、、、、和 标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： &lt;hn> 标题文本 &lt;/hn> 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。 段落标签( 熟记)单词缩写： paragraph 段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 &lt;p> 文本内容 &lt;/p> 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： &lt;hr />是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br /> 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： &lt;div> 这是头部 &lt;/div> &lt;span>今日价格&lt;/span> 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： &lt;标签名 属性1="属性值1" 属性2="属性值2" …> 内容 &lt;/标签名> 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: &lt;hr width="400" /> 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 &lt;img src="图像URL" /> 链接标签(重点)单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： &lt;a href="跳转目标" target="目标窗口的弹出方式">文本或图像&lt;/a> href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 1.使用“a href=”#id名>“链接文本"&lt;/a>创建链接文本。 2.使用相应的id名标注跳转目标的位置。 base 标签base 可以设置整体链接的打开状态 base 写到 之间 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ &lt;!-- 注释语句 --> 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径和绝对路径 相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径 “D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： &lt;ul> &lt;li>列表项1&lt;/li> &lt;li>列表项2&lt;/li> &lt;li>列表项3&lt;/li> ...... &lt;/ul> 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。 3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： &lt;ol> &lt;li>列表项1&lt;/li> &lt;li>列表项2&lt;/li> &lt;li>列表项3&lt;/li> ...... &lt;/ol> 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： &lt;dl> &lt;dt>名词1&lt;/dt> &lt;dd>名词1解释1&lt;/dd> &lt;dd>名词1解释2&lt;/dd> ... &lt;dt>名词2&lt;/dt> &lt;dd>名词2解释1&lt;/dd> &lt;dd>名词2解释2&lt;/dd> ... &lt;/dl> 用的还可以： 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 表格 table(会使用) 存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： &lt;table> &lt;tr> &lt;td>单元格内的文字&lt;/td> ... &lt;/tr> ... &lt;/table> 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 1.table用于定义一个表格。 2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。 3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示： &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。 必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。 &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。 位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题表格的标题： caption 定义和用法 caption 元素定义表格标题。 &lt;table> &lt;caption>我是表格标题&lt;/caption> &lt;/table> caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。 合并单元格(难点)跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 合并的顺序 先上 先左 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 表格的学习要求： 能手写表格结构，并且能合并单元格。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 &lt;label for="male">Male&lt;/label> &lt;input type="radio" name="sex" id="male" value="male"> textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： &lt;textarea cols="每行中的字符数" rows="显示的行数"> 文本内容 &lt;/textarea> 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 &lt;select> &lt;option>选项1&lt;/option> &lt;option>选项2&lt;/option> &lt;option>选项3&lt;/option> ... &lt;/select> 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： &lt;form action="url地址" method="提交方式" name="表单名称"> 各种表单控件 &lt;/form> 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 HTML5新标签与特性 文档类型设定 document HTML: sublime 输入 html:4s XHTML: sublime 输入 html:xt HTML5 sublime 输入 html:5 &lt;!DOCTYPE html&gt; 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 w3c 手册中文官网 : http://w3school.com.cn/ header：定义文档的页眉 头部 nav：定义导航链接的部分 footer：定义文档或节的页脚 底部 article：定义文章。 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 侧边 &lt;header> 语义 :定义页面的头部 页眉&lt;/header> &lt;nav> 语义 :定义导航栏 &lt;/nav> &lt;footer> 语义: 定义 页面底部 页脚&lt;/footer> &lt;article> 语义: 定义文章&lt;/article> &lt;section> 语义： 定义区域&lt;/section> &lt;aside> 语义： 定义其所处内容之外的内容 侧边&lt;/aside> datalist 标签定义选项列表。请与 input 元素配合使用该元素 &lt;input type="text" value="输入明星" list="star"/> &lt;!-- input里面用 list --> &lt;datalist id="star"> &lt;!-- datalist 里面用 id 来实现和 input 链接 --> &lt;option>刘德华&lt;/option> &lt;option>刘若英&lt;/option> &lt;option>刘晓庆&lt;/option> &lt;option>郭富城&lt;/option> &lt;option>张学友&lt;/option> &lt;option>郭郭&lt;/option> &lt;/datalist> fieldset 元素可将表单内的相关元素分组，打包 legend 搭配使用 用户登录 标题 用户名: 密 码: 新增的input type属性值： 类型** 使用示例** 含义** email** 输入邮箱格式 tel** 输入手机号码格式 url** 输入url格式 number** 输入数字格式 search** 搜索框（体现语义化） range** 自由拖动滑块 time** 小时分钟 date** 年月日 datetime** 时间 month** 月年 week** 星期 年 ## 常用新属性 属性** 用法** 含义** placeholder** 占位符 当用户输入的时候 里面的文字消失 删除所有文字，自动返回 autofocus** 规定当页面加载时 input 元素应该自动获得焦点 multiple** 多文件上传 autocomplete** 规定表单是否应该启用自动完成功能 有2个值，一个是on 一个是off on 代表记录已经输入的值 1.autocomplete 首先需要提交按钮 2.这个表单您必须给他名字 required** 必填项 内容不能为空 accesskey** 规定激活（使元素获得焦点）元素的快捷键 采用 alt + s的形式 综合案例&lt;form action=""> &lt;fieldset> &lt;legend>学生档案&lt;/legend> &lt;label for="userName">姓名:&lt;/label> &lt;input type="text" name="userName" id="userName" placeholder="请输入用户名"> &lt;br> &lt;label for="userPhone">手机号码:&lt;/label> &lt;input type="tel" name="userPhone" id="userPhone" pattern="^1\d{10}$">&lt;br> &lt;label for="email">邮箱地址:&lt;/label> &lt;input type="email" required name="email" id="email">&lt;br> &lt;label for="collage">所属学院:&lt;/label> &lt;input type="text" name="collage" id="collage" list="cList" placeholder="请选择">&lt;br> &lt;datalist id="cList"> &lt;option value="前端与移动开发学院">&lt;/option> &lt;option value="java学院">&lt;/option> &lt;option value="c++学院">&lt;/option> &lt;/datalist>&lt;br> &lt;label for="score">入学成绩:&lt;/label> &lt;input type="number" max="100" min="0" value="0" id="score">&lt;br> &lt;form action=""> &lt;fieldset> &lt;legend>学生档案思密达&lt;/legend> &lt;label>姓名: &lt;input type="text" placeholder="请输入学生名字"/>&lt;/label> &lt;br />&lt;br /> &lt;label>手机号: &lt;input type="tel" />&lt;/label> &lt;br />&lt;br /> &lt;label>邮箱: &lt;input type="email" />&lt;/label> &lt;br />&lt;br /> &lt;label>所属学院: &lt;input type="text" placeholder="请选择学院" list="xueyuan"/> &lt;datalist id="xueyuan"> &lt;option>java学院&lt;/option> &lt;option>前端学院&lt;/option> &lt;option>php学院&lt;/option> &lt;option>设计学院&lt;/option> &lt;/datalist> &lt;br />&lt;br /> &lt;label>出生日期: &lt;input type="date" />&lt;/label> &lt;br />&lt;br /> &lt;label>成绩: &lt;input type="number" />&lt;/label> &lt;br />&lt;br /> &lt;label>毕业时间: &lt;input type="date" />&lt;/label> &lt;br />&lt;br /> &lt;input type="submit" /> &lt;input type="reset" /> &lt;/fieldset> &lt;/form> &lt;label for="inTime">入学日期:&lt;/label> &lt;input type="date" id="inTime" name="inTime">&lt;br> &lt;label for="leaveTime">毕业日期:&lt;/label> &lt;input type="date" id="leaveTime" name="leaveTime">&lt;br> &lt;input type="submit"> &lt;/fieldset> &lt;/form> 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 &lt;embed src="http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash">&lt;/embed> 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 loop = 2 就是循环2次 loop 或者 loop = “-1” 无限循环 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 多媒体 videoHTML5通过标签来解决音频播放的问题。 同音频播放一样，使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图** 总结 HTML 第二天的主题： 熟悉列表— 会使用表格 — 掌握常用表单]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F10%2F13%2Fvue%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[vuepress]]></title>
    <url>%2F2019%2F10%2F11%2Fvuepress%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Front]]></title>
    <url>%2F2019%2F09%2F08%2FFront%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[macbook]]></title>
    <url>%2F2019%2F09%2F05%2Fmacbook%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[newblog]]></title>
    <url>%2F2019%2F08%2F12%2Fnewblog%2F</url>
    <content type="text"><![CDATA[New Blog from Hexo-theme-matery]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>NexT</tag>
        <tag>Hexo-theme-matery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MindMap]]></title>
    <url>%2F2019%2F07%2F24%2FMindMap%2F</url>
    <content type="text"><![CDATA[利用思维导图高效率的学习与整理知识]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
      <tags>
        <tag>Mind</tag>
        <tag>XMind</tag>
        <tag>MindMap</tag>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitee]]></title>
    <url>%2F2019%2F05%2F19%2Fgitee%2F</url>
    <content type="text"><![CDATA[部署GitHub项目同步到Gitee 同一台电脑上部署个人博客到GitHub Pages 部署个人小项目到Gitee Pages]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>gitee</tag>
        <tag>hexo</tag>
        <tag>ssh key</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code Extensions You Should Know]]></title>
    <url>%2F2019%2F05%2F12%2Fvscode-extensions%2F</url>
    <content type="text"><![CDATA[VS Code Extensions You Should KnowVS CodeVS code特点： 开源，免费； 自定义配置 集成git 智能提示强大 支持各种文件格式（html/jade/css/less/sass/xml） 调试功能强大 各种方便的快捷键 强大的插件扩展 Visual Studio Code（VScode ）官网 ：https://code.visualstudio.com/Visual Studio Code（VScode ）github地址 ：https://github.com/Microsoft/vscode 如何安装插件​ 按F1或Ctrl+Shift+p，输入extensions，点击第一个就可以 插件合集​ 插件官网：*https://marketplace.visualstudio.com/ 配置类插件Settings Sync​ 最好用的插件，没有之一，一台电脑配置好之后，其它的几台电脑都不用配置。新机器登录一下就搞定了。再也不用折腾环境了，​ 使用GitHub Gist同步多台计算机上的设置，代码段，主题，文件图标，启动，键绑定，工作区和扩展。 Debugger for Chrome​ 从VS Code调试在Google Chrome中运行的JavaScript代码。​ 用于在Google Chrome浏览器或支持Chrome DevTools协议的其他目标中调试JavaScript代码的VS Code扩展。 beautify​ 格式化代码工具​ 美化javascript，JSON，CSS，Sass，和HTML在Visual Studio代码。 Auto Rename Tag​ 修改 html 标签，自动帮你完成头部和尾部闭合标签的同步修改 中文（简体）语言包​ 将界面转换为中文，对英语不好的人，非常友好。 Code Spell Checker​ 代码拼写检查器​ 一个与camelCase代码配合良好的基本拼写检查程序。​ 此拼写检查程序的目标是帮助捕获常见的拼写错误，同时保持误报数量较低。 vscode-icons​ 显示Visual Studio代码的图标，目前该插件已被vscode内部支持：”文件” -&gt; “首选项” -&gt; “文件图标主题” guides​ 显示代码对齐辅助线，很好用 Rainbow Brackets​ 为圆括号，方括号和大括号提供彩虹色。这对于Lisp或Clojure程序员，当然还有JavaScript和其他程序员特别有用。 Bracket Pair Colorizer​ 用于着色匹配括号 filesize​ 在状态栏中显示当前文件大小，点击后还可以看到详细创建、修改时间 WakaTime​ 从您的编程活动自动生成的度量标准，见解和时间跟踪。 Language Support for Java(TM) by Red Hatredhat.java​ 这个插件，这个下载次数，安装就对了。 Todo Tree​ 此扩展可以快速搜索（使用ripgrep）您的工作区以获取TODO和FIXME等注释标记，并在资源管理器窗格的树视图中显示它们。单击树中的TODO将打开文件并将光标放在包含TODO的行上。找到的TODO也可以在打开的文件中突出显示。 VS code 主题配色Night Owl​ 一个非常适合夜猫子的 VS Code 主题。像是为喜欢深夜编码的人精心设计的。 Atom One Dark Theme​ 一个基于Atom的黑暗主题 Dracula Official​ 官方吸血鬼主题，博主用的就是这款，很漂亮 One Dark Pro​ Atom标志性的One Dark主题，也是VS Code下载次数最多的主题之一！ Bimbo​ 简约而现代的神奇海洋主题 代码提示类HTML Snippets 完整的HTML代码提示，包括HTML5 HTML CSS Support​ 在 html 标签上写class 智能提示css样式 jQuery Code Snippets​ jQuery代码提示​ 超过130个用于JavaScript代码的jQuery代码片段。​ 只需键入字母’jq’即可获得所有可用jQuery代码片段的列表。 HTMLHinthtml代码检测，支持html5 语言相关C＃ 适用于.NET Core的轻量级开发工具。 伟大的C＃编辑支持，包括语法突出显示，智能感知，转到定义，查找所有引用等。 调试支持.NET Core（CoreCLR）。注意：不支持单声道调试。桌面CLR调试支持有限。 支持Windows，macOS和Linux上的project.json和csproj项目。 CodeMetrics​ 计算TypeScript / JavaScript文件的复杂性。 VUE插件​ vetur 语法高亮、智能感知、Emmet等​ VueHelper snippet代码片段 Java Extension Pack 它是一组流行的扩展，可以帮助在Visual Studio Code中编写，测试和调试Java应用程序。查看VS Code中的Java以开始使用。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Front</tag>
        <tag>Developer Tools</tag>
        <tag>VS Code</tag>
        <tag>Extensions</tag>
        <tag>Vue</tag>
        <tag>Git</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 打造前端开发环境]]></title>
    <url>%2F2019%2F05%2F08%2Fmacweb%2F</url>
    <content type="text"><![CDATA[macOS Mojave 打造高效率前端开发环境### 安装Homebrew​ 包管理工具。类似于node下的npm。可以用来安装管理大部分的无界面的工具，如node，git，Python等。​ 摘自官网的安装命令： /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装Gitbrew install git 安装npmnpm install npm -g 安装webpacknpm install webpack -g 用 iTerm2 代替Mac Terminal ​ Mac原生terminal 也很强大也可以设置很美观，但是iTerm2 明显更优秀。 安装​ 首先我们下载的 iTem2 这个软件，比Mac自带的终端更加强大。直接官网 http://iterm2.com/ 下载并安装即可。 配置​ 将iTem2设置为默认终端：（菜单栏）iTerm2 -&gt; Make iTerm2 Default Term ​ ​ 然后打开偏好设置preference，选中Keys，勾选Hotkey下的Show/hide iTerm2 with a system-wide hotkey，我将热键设置为 Option + Space，这样你就可以通过Option + Space . 全局热键来打开或关闭iTerm2窗口，非常方便。 主题配色​ 首先我来介绍一下如何下载并应用我们看好的主题配置文件。 ​ 我们可以点击 这个链接 直接下载主题项目的所有文件，得到压缩包，解压即可。使用 git 版本控制系统的同学也可以通过下面这个命令将 GitHub 仓库整个克隆至本地： git clone https://github.com/mbadolato/iTerm2-Color-Schemes.git ​ 我个人推荐One Dark 主题。One 系列主题同样也有一暗一亮两个配色方案。其中的 One Dark 是 Atom 编辑器的默认主题配色，简洁、养眼。不得不承认这一主题确实很符合我的胃口，我现在所有可以配色的地方（比如各种终端和 VS Code 等编辑器）几乎就直接使用 One Dark 配色。 ​ 这是我的iTerm2界面，自认为很简洁美观。 推荐链接：10 个 Terminal 主题，让你的 macOS 终端更好看 安装oh-my-zsh​ github连接：https://github.com/robbyrussell/oh-my-zsh ​ 使用 crul 安装： sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" ​ 或使用wget： `sh -c ``"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"` 编辑器Vusual Studio Code​ Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). 支持的拓展常见的包含如下： 优点：​ 重新定义了 Code 编辑。 ​ 在任何操作系统上编辑和调试应用程序 ​ 内置 Git 支持 ，1000 种以上的扩展 ​ 免费和开源 官网：Vusual Studio Code下载安装；Downloads官方文档：VS Code Docs扩展官网：Extensions Marketplace推荐扩展​ 我将单独写一篇博文具体介绍一些实用的开发插件。 WebStorm​ WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。目前已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 Submlie Text3下载安装：官网插件推荐：]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>Front</tag>
        <tag>macOS</tag>
        <tag>Software</tag>
        <tag>Developer Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deeplearning]]></title>
    <url>%2F2019%2F04%2F19%2Fdeeplearning%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[evil]]></title>
    <url>%2F2019%2F04%2F15%2Fevil%2F</url>
    <content type="text"><![CDATA[Terminal 主题，让你的 macOS 终端更好看]]></content>
      <tags>
        <tag>Hackintosh</tag>
        <tag>MacOS</tag>
        <tag>Tools</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS]]></title>
    <url>%2F2019%2F04%2F14%2FMacOS%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[从Linux Deepin 系统迁移Blog到 MacOS Mojave]]></title>
    <url>%2F2019%2F04%2F13%2Fhack%2F</url>
    <content type="text"><![CDATA[Hexo Blog + Github Pages 从 Deepin 15.9.3 迁移至 MacOS Mojave 10.14.4安装git和node.js 首先在自己电脑上转好node和git brew install git brew install node 安装hexo 用node.js来安装 npm install hexo g 初始化hexo 新建一个hexo目录，然后在 hexo init 在用hexo s测试是否成功，打开localhost:4000查看本地 生成SSH key 先查看本地的SSH key: cd ~/.ssh 然后生成一个SSH key ssh-keygen -t rsa -C &quot;xxxxxx@xxx.com&quot;,后面那个是注册邮箱 添加SSH key到自己github 进入.ssh文件夹： cd ~/.ssh，然后打开里面的 id_rsa.pub文件，里面的内容就是 SSH key，复制全部内容； 网页打开 github 的设置：Settings -&gt; SSH and GPG keys，点击绿色的按钮 New SSH key，然后在输入框中输入刚才复制的内容； 保存后，github 会向你的邮箱发送一个验证链接（记得要去登录邮箱验证，不然之后的 hexo d 部署会一直不成功的！）； 测试一下是否成功：ssh git@github.com， 看到以下即成功： PTY allocation request failed on channel 0 Hi gjincai! You&#39;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 文件配置转移 windows 下的博客根目录 hexo，复制该目录下的：_config.yml, scaffolds, source, themes； mac 下的博客根目录 hexo，把刚才复制的内容，直接覆盖替换相同的文件文件夹。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Github</tag>
        <tag>MacOS Mojave 10.14.4</tag>
        <tag>Hexo</tag>
        <tag>Deepin</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米Pro笔记本 Hackintosh MacOS Mojave 10.14.4 安装教程]]></title>
    <url>%2F2019%2F04%2F10%2FHackintosh%2F</url>
    <content type="text"><![CDATA[前言Mi Pro Hackintosh MacOS Mojave 10.14.4 本文仅针对小米笔记本Pro，其他机型可作参考，需要找到对应的EFI替换。本文部分内容引用：macOS安装教程兼小米Pro安装过程记录 此教程大部分准备工作在win下进行已尽量通俗易懂了。 让你的小米笔记本Pro吃上黑苹果，体验MacBook Pro 95%的功能 电脑配置 规格 详细信息 电脑型号 小米笔记本电脑Pro 15.6’’(MX150/GTX) 处理器 英特尔 酷睿 i5-8250U/i7-8550U 处理器 内存 8GB/16GB 三星 DDR4 2400MHz 硬盘 三星 NVMe固态硬盘 PM961 256GB 集成显卡 英特尔 UHD 图形620 显示器 京东方 NV156FHM-N61 FHD 1920x1080 (15.6 英寸) 声卡 瑞昱 ALC298 (节点:30/99) 网卡 英特尔 无线 8265 读卡器 瑞昱 RTS5129 问题哪些不能正常工作 独立显卡，因为macOS不支持Optimus技术 使用了SSDT-DDGPU来禁用它以节省电量 指纹传感器 使用了USBPorts来禁用它以节省电量 英特尔蓝牙只有在从Windows热重启后有效 阅读蓝牙解决方案 英特尔无线网卡 购买USB网卡或者支持的内置网卡 瑞昱USB SD读卡器 使用了USBPorts来禁用它以节省电量 其他都工作正常 在PM981上发生内核错误，无法安装 目前PM981在macOS 10.13.3+上无解。你可以安装macOS到另一块硬盘上。 PM981硬盘序列号以MZVLB开头，PM961硬盘序列号以MZVLW` 开头。 哪些可以工作得更好 使用ALCPlugFix来修复耳机重新插拔后无声 使用DVMT_and_0xE2_fix来把帧缓存设为64mb并解锁CFG 使用one-key-hidpi来提升系统UI质量 使用one-key-cpufriend来提升CPU性能 下载文件及工具 一个容量8G及以上的U盘 MacOS镜像： 最新镜像：【黑果小兵】MacOS Mojave 10.14.4 18E226 正式版 with Clover 4903原版镜像 Windows下工具： BalenaEtcher:把MacOS镜像写进U盘 WinMD5:验证镜像文件的MD5值。 DiskGenius：对硬盘分区修改 Bootice：添加UEFI引导选项 微PE：用于硬盘ESP分区扩容 Win工具下载地址： 百度云： 小米Pro专用EFI持续长期更新 https://github.com/daliansky/XiaoMi-Pro 开始制作安装镜像 镜像制作： 使用WinMd5验证下载的MacOS的MD5值， MD5 (macOS Mojave 10.14.4(18E226) Installer with Clover 4903.dmg) = ee923768b29194efc704bcf34d7f9fd8 下载etcher，打开镜像，选择U盘，点击Flash即可。 复制EFI 将镜像里的EFI复制到USB安装盘的EFI分区下 解压下载的EFI文件，选择EFI用快捷键ctrl+c 复制 打开DiskGenius分区软件删除U盘的EFI目录 在DiskGenius分区软件下用快捷键ctrl+v 把新的EFI复制进去 复制EFI到硬盘的EFI分区 操作完成后目录结构应与下图一致，此处注意Microsoft为windows引导.如何想安装Win10和MacOS双系统，里面文件不要动，否则windows无法引导。 制作PE 在DiskGenius分区软件下操作，右键点击U盘空闲区域建立新分区 分区格式为FAT32，大小为500M，确定并保存设置 注意要安装PE不影响之前做好的macOS安装盘需要把U盘其他分区的盘符隐藏，仅保留刚才创建的500M分区盘符 打开微PE工具箱安装程序选择安装方式为安装到U盘 如下图安装方式选择方式三UEFI全能单分区，取消勾选格式化，然后点击安装进U盘 添加UEFI引导选项 使用工具:BOOTICE 操作过程: 打开BOOTICE软件,选择物理磁盘,选择欲操作的目标磁盘,点击分区管理,弹出分区管理的窗口,点击分配盘符,为ESP分区分配一个盘符,点击确定 选择UEFI,点击修改启动序列,点击添加按钮,菜单标题填写:CLOVER,选择启动文件,在打开的窗口里选择ESP分区下的目录\EFI\CLOVER\CLOVERX64.EFI,选中CLOVER上移到最上面，点击保存当前启动项设置 ​ 小米BIOS设置​ 小米笔记本的BIOS默认开启了安全认证,UEFI引导需要关闭安全启动Secure Boot Mode方式,否则无法加载UEFI引导设备,比如刚制作好的macOS安装USB盘 操作方法: 开机按F2进入BIOS设置,光标移动到Security,点击Set Supervisor Password设置一个BIOS密码,输入两次相同的密码,点击YES保存。***这个BIOS密码非常重要，一定要设置成常用的密码并且备份，我现在就是忘了BIOS密码进不去BIOS，走售后只能换主板，价格3000+。 欲哭无泪中。。千万记得备份密码***。 关闭安全启动，点击Secure Boot Mode,设置为Disabled关闭安全启动 按F10保存设置并退出BIOS PE下扩容ESP(EFI)分区 MacOS系统要求EFI为200M以上，否则安装时无法抹盘 操作方法1：插上U盘开机按F12键进入Boot Manager引导管理,选择 EFI USB Device1,回车 进入PE 使用分区助手（无损）删除MSR分区 选中ESP(EFI)分区 右键选择调整移动分区 如图拉到最右边，扩容efi分区，确定并提交更改。 安装macOS 开机按F12键进入Boot Manager引导管理,选择 EFI USB Device,回车进入macOS安装程序 移动光标到Boot OS X Install from XiaoMiPro 10131回车 安装第一阶段开始引导macOS系统 ​ 这个过程需要1-2分钟,耐心等待进入安装程序,出现语言选择界面. 语言选择 选择简体中文 出现macOS实用工具界面,选择磁盘工具 磁盘工具 选择显示所有设备: 选择SSD Media,点击抹掉按钮,选择默认的Mac OS扩展(日志型),将名称修改为Macintosh HD,点击抹掉按钮.(PS:会抹掉磁盘上所有内容，之前记得备份) 抹盘成功后,它会自动生成一个200MB的EFI分区,这样做的好处是不会出现安装过程中的由于EFI分区尺寸小于200MB而引起的无法安装的错误.当然前提是你的磁盘中没有重要的数据,或者您的数据已经提前备份过了. 到这里,磁盘工具的动作就已经结束了.按左上角x ,退出磁盘工具进入安装界面,进行系统的安装了. 安装macOS 进入安装界面 选择继续，同意 选择刚刚抹掉的分区，安装 会自动重启数次。 安装第二阶段 第二阶段的安装会有两种界面,一种是不进安装界面直接安装,另一种是先进入安装界面直接安装,需要注意的是,无论是哪一种界面下,安装的过程中全程是禁用鼠标和键盘的,需要你做的只是耐心等待它安装完成 安装速度取决于你的磁盘速度,第二阶段的安装已经与USB安装盘没什么关系了.macOS 10.13的安装完全区别于10.12,它不能免二次安装,甚至还需要重启多次,这些都是正常现象,请不要大惊小怪的. 系统安装完成后,重启进入系统设置向导 设置向导国家选择 首先让你选择国家,这里我选择中国 点击继续,设置键盘。 设置键盘 这里询问你是否传输信息到这台Mac 数据恢复 可以从Mac或者Time Machine备份恢复 我选择现在不传输任何信息,点击继续 Apple ID登录 选择是否使用您的Apple ID登录,如何想现在就登录到Apple ID,请输入Apple ID和密码登录,否则选择不登录,进入系统后也可以设置登录到iCloud,点击继续 阅读条款与条件,选择同意继续 出现创建电脑用户的窗口,输入用户名和密码,点击继续 创建电脑用户 用户创建成功后,弹出iCloud的正在设置用户的窗口 紧接着弹出设置iClound钥匙串的设置窗口,选择稍候设置,点击继续 出现正在设置您的Mac,请稍候完成设置向导 设置向导完成 出现桌面后,整个的安装向导就完成了. 安装后的系统设置 系统安装后,你可以先喝杯咖啡兴奋会儿,马上还有更艰巨的任务在等着你呢 MacOS:教你将U盘上的EFI复制到磁盘的EFI分区,脱离USB运行 diskutil命令的基本用法： 查看磁盘分区表 diskutil list ​ /dev/disk0(internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 256 GB disk0 1: EFI EFI 200 MB disk0s1 2: Apple_HFS MAC 128 GB disk0s2 3: Microsoft Basic Data WIN10 127.7 GB disk0s3 ​ /dev/disk1(internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 16 GB disk1 1: EFI EFI 200 MB disk1s1 2: Apple_HFS Install macOS Sierra 15.8 GB disk1s2 挂载磁盘EFI分区 sudo diskutil mount disk0s1 挂载U盘EFI分区 sudo diskutil mount disk1s1 打开Finder，注意后面有个. open . 左侧会显示挂载了两个EFI分区，将U盘EFI目录全部复制到磁盘的EFI分区即可。 完善驱动USB网卡推荐： COMFAST CF-WU810N 驱动下载：COMFAST CF-WU810N 网卡驱动.zip 重建缓存 重建缓存 Kext Utility.zip 使用Kext Utility 重建缓存然后重启就可以正常使用了。 参考链接 macOS安装教程兼小米Pro安装过程记录 【老司机引路】小米笔记本pro Win10+黑苹果macOS 10.13.6双系统 Hackintosh Your Xiaomi NoteBook Pro XiaoMi NoteBook Pro for macOS Mojave &amp; High Sierra]]></content>
      <categories>
        <category>黑苹果</category>
        <category>MacOS Mojave 10.14.4安装教程</category>
      </categories>
      <tags>
        <tag>Hackintosh</tag>
        <tag>MacOS</tag>
        <tag>Tools</tag>
        <tag>小米Pro</tag>
        <tag>macOS Mojave 10.14.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github Pages + Hexo搭建个人技术博客]]></title>
    <url>%2F2019%2F04%2F01%2Fblogspace%2F</url>
    <content type="text"><![CDATA[用Github Pages + Hexo搭建个人技术博客序Hexo安装过后，默认的主题是landscape，如果不喜欢，我们也可以进行更换。本文主要讲解NexT主题的使用。先看下我博客网站的效果吧：wjingc.github.io,我使用的主题是 Mist. 主要网站 Github Hexo Next 目录Github配置注册Github账号打开https://github.com/站点，注册一个账号 创建Github仓库接下来到这个页面去创建一个新仓库https://github.com/new 这个新仓库就将是存放你即将拥有的博客的地方 注意，你的仓库名不能随便取，这样会导致github混乱，取名的格式应该为“用户名.github.io” 后面的操作照配图做就可以了 生成Github Pages建完仓库后，在当前页面右边选择Settings，进入设置页面，在这里生成你的github pages 系统环境配置安装Node.js参考地址：Node.js安装配置 安装Gitapt-get install git 安装Hexocd d:/hexo npm install hexo-cli -g hexo init blog cd blog npm install hexo g # 或者hexo generate hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 这里有必要提下Hexo常用的几个命令： hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server (hexo s) 启动本地web服务，用于博客的预览 hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 另外还有其他几个常用命令： 另外还有其他几个常用命令： hexo new "postName" #新建文章 hexo new page "pageName" #新建页面 常用简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 常用组合 hexo d -g #生成部署 hexo s -g #生成预览 现在我们打开http://localhost:4000/ 已经可以看到一篇内置的blog了。 Hexo主题设置我选的是NexT主题，主题喜好根据自己选择。 Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 下载主题如果你熟悉 Git，建议你使用克隆最新版本的方式，之后的更新可以通过 git pull 来快速更新， 而不用再次下载压缩包替换。 在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码： cd blog git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。 启用 NexT 主题 theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse NexT主题配置美化选择 SchemeScheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 选择 Mist Scheme #scheme: Muse scheme: Mist #scheme: Pisces 设置语言编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下： language: zh-Hans 目前 NexT 支持的语言如以下表格所示： 语言 代码 设定示例 English en language: en 简体中文 zh-Hans language: zh-Hans Français fr-FR language: fr-FR Português pt language: pt or language: pt-BR 繁體中文 zh-hk 或者 zh-tw language: zh-hk Русский язык ru language: ru Deutsch de language: de 日本語 ja language: ja Indonesian id language: id Korean ko language: ko 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 编辑 主题配置文件，修改以下内容： 设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。 菜单示例配置 menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 的项表示需要手动创建这个页面）： | 键值 | 设定值 | 显示文本（简体中文） || ———- | ————————- | ——————– || home | home: / | 主页 || archives | archives: /archives | 归档页 || categories | categories: /categories | 分类页 || tags | tags: /tags | 标签页 || about | about: /about | 关于页面 || commonweal | commonweal: /404.html | 公益 404 | 设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml（{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件languages/zh-Hans.yml，在 menu 字段下添加一项： menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。 菜单图标配置示例 menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 请注意键值（如 home）的大小写要严格匹配 设置侧栏默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置 目前仅 Pisces Scheme 支持 position 配置。影响版本5.0.0及更低版本。 sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 sidebar: display: post 已知侧栏在 use motion: false 的情况下不会展示。 影响版本5.0.0及更低版本。 设置头像编辑 主题配置文件， 修改字段 avatar， 值设置成头像的链接地址。其中，头像的链接地址可以是： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 头像设置示例 avatar: http://example.com/avatar.png 设置作者昵称编辑 站点配置文件， 设置 author 为你的昵称。 站点描述编辑 站点配置文件， 设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 下一步：配置Hexo-NexT，使你的博客酷炫 参考链接 手把手教你使用Hexo + Github Pages搭建个人独立博客 开始使用NexT Hexo-NexT配置超炫网页效果]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Hexo-NexT，使你的博客酷炫]]></title>
    <url>%2F2019%2F03%2F29%2FNexT%2F</url>
    <content type="text"><![CDATA[目录NexT安装 切换到Blog文件夹下（就是hexo init的文件夹），查看文件 cd [Blog] ls _config.yml node_modules scaffolds themes db.json package.json source 通过git安装，前提是你的电脑安装了git. git clone https://github.com/iissnan/hexo-theme-next themes/next 查看标签列表 git tag -l 输出： ... v5.1.3 v5.1.4 切换到v5.1.4 git checkout tags/v5.1.4 输出： HEAD is now at 4f75fe5... 2018 NY update. 通过curl安装NexT mkdir themes/next curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 更新主题NexT cd themes/next git pull 切换成NexT主题，在hexo根文件夹下，编辑_config.yml文件 theme: next //切换后，用命令清除下缓存 hexo clean //执行hexo s本地产看NexT主题效果 hexo s 切换主题 在列表中选择一款自己喜欢的主题风格。 # Schemes #scheme: Muse //默认主题 scheme: Mist #scheme: Pisces #scheme: Gemini 设置Menu 默认只有两个首页和归档，如下图所示： 如果还要添加，编辑themes/next/_config.yml： menu: home: / || home //首页 about: /about/ || user //关于 tags: /tags/ || tags //标签 categories: /categories/ || th //分类 archives: /archives/ || archive //归档 schedule: /schedule/ || calendar //日程表 sitemap: /sitemap.xml || sitemap //站点地图 将需要的Menu前面#号去掉。如下图所示: 初始化对应的Menu文件夹没有创建Menu对应的文件夹，Blog/source文件目录如下： 在博客网站点击标签菜单可能会提示： 比如要创建标签文件夹，终端中输入（前提在Hexo文件路径下）： hexo new page "tags" 输出： INFO Created: ~/Desktop/MyBlog/Blog/source/tags/index.md 成功过后目录如下： 编辑Blog/source/tags中index.md文件，添加type: &quot;tags&quot;，其他Menu也同理创建。 title: tags date: 2018-01-20 18:57:48 type: "tags" 设置动态背景 主题配置文件内置4种特效，选择你喜欢的，设置成ture就OK啦。 # Canvas-nest canvas_nest: false # three_waves three_waves: true # canvas_lines canvas_lines: false # canvas_sphere canvas_sphere: false 在右上角或者左上角实现fork me on github 效果图如下所示： 在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码： 将刚刚复制的挂饰代码，添加到Blog/themes/next/layout/_layout.swig文件中，添加位置如下图所示(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下方)： 添加添加RSS 切换到Blog文件夹（hexo init的文件夹）下 cd [Blog] 安装Hexo插件 npm install --save hexo-generator-feed 安装成功之后，编辑Blog/_config.yml文件，在文件末尾添加 # Extensions ## Plugins: http://hexo.io/plugins/ plugins: hexo-generate-feed 配置主题_config.yml文件，command+f搜索rss，在后面加上/atom.xml # Set rss to false to disable feed link. # Leave rss as empty to use site's feed link. # Set rss to specific value if you have burned your feed already. rss: /atom.xml //注意：有一个空格 之后，终端输入hexo s查看效果 hexo s 修改文章内链接文本样式 修改Blog/themes/next/source/css/_common/components/post/post.styl，在末尾添加CSS样式： // 文章内链接文本样式 .post-body p a{ color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover { color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 } } 设置后，效果如下 修改底部标签样式 修改Blog\themes\next\layout\_macro\post.swig中文件，command+f搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。输入以下命令，查看效果： hexo clean hexo s 在文章末尾添加“文章结束”标记 在路径Blog\themes\next\layout\_macro文件夹中新建passage-end-tag.swig文件。 //切换到路径_macro cd [_macro路径] //创建passage-end-tag.swig文件 touch passage-end-tag.swig 在passage-end-tag.swig添加以下内容，直接用文本编辑器打开，粘贴以下内容后保存 &lt;div> {% if not is_index %} &lt;div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束&lt;i class="fa fa-paw">&lt;/i>感谢您的阅读-------------&lt;/div> {% endif %} &lt;/div> 打开Blog\themes\next\layout\_macro\post.swig，在post-body之后，post-footer之前（post-footer之前两个DIV），添加以下代码： &lt;div> {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div> 添加位置，如下图所示： 修改主题配置文件_config.yml，在末尾添加： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 配置完成之后，效果如下： 设置头像并设置动画效果 在Blog/_config.yml中添加头像链接地址： //添加头像地址 avatar: [ http://....] 设置头像圆角并旋转，打开Blog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl，添加以下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 效果如下： 修改代码块自定义样式 打开Blog\themes\next\source\css\_custom\custom.styl，添加以下代码： // Custom styles. code { color: #ff7600; background: #fbf7f8; margin: 2px; } // 大代码块的自定义样式 .highlight, pre { margin: 5px 0; padding: 5px; border-radius: 3px; } .highlight, code, pre { border: 1px solid #d6d6d6; } 侧边栏社交小图标设置 打开主题配置文件_config.yml，command+f搜索Social，将你有的社交账号前面的#号去掉。格式为： [社交平台名]: [社交地址] || [图标名称] #social: GitHub: https://github.com/yourname || github 简书: https://www.jianshu.com/u/63445e24e8bf || heartbeat 掘金: https://juejin.im/user/5a371ae551882512d0607108 || spinner #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 效果图如下： 图标可以去Font Awesome Icon网站去找，找到后复制名字到相应的位置即可。 主页文章添加阴影效果 打开Blog\themes\next\source\css\_custom\custom.styl，添加以下代码： // 主页文章添加阴影效果 .post { margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 效果如下： 网站底部加上访问量 打开Blog/themes/next/layout/_partials/footer.swig文件，在copyright加上如下代码： &lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">&lt;/script> 在适当的位置添加显示统计代码 &lt;div class="powered-by"> &lt;i class="fa fa-user-md">&lt;/i>&lt;span id="busuanzi_container_site_uv"> 本站访客数:&lt;span id="busuanzi_value_site_uv">&lt;/span> &lt;/span> &lt;/div> 设置统计方式 //pv的方式，单个用户连续点击n篇文章，记录n次访问量 &lt;span id="busuanzi_container_site_pv"> 本站总访问量&lt;span id="busuanzi_value_site_pv">&lt;/span>次 &lt;/span> //uv的方式，单个用户连续点击n篇文章，只记录1次访客数 &lt;span id="busuanzi_container_site_uv"> 本站总访问量&lt;span id="busuanzi_value_site_uv">&lt;/span>次 &lt;/span> 效果图如下： 网站底部字数统计 安装hexo插件，切换到根目录： npm install hexo-wordcount --save 在Blog/themes/next/layout/_partials/footer.swig末尾添加代码： &lt;div class="theme-info"> &lt;div class="powered-by">&lt;/div> &lt;span class="post-count">博客全站共{{ totalcount(site) }}字&lt;/span> &lt;/div> 效果图如下图所示： 设置网站的图标Favicon 在图标网站找一张你喜欢的图标（大：32x32 小：16x16），图标网站：easyicon或者阿里巴巴矢量图标库。将下载下来的小图和中图放在Blog/themes/next/source/images，将默认的两张图片替换掉。命名和默认的一样也可以自己定义： 修改主题配置文件，如果你自定义了图片名字，需要做修改： # For example, you put your favicons into `hexo-site/source/images` directory. # Then need to rename & redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo. favicon: small: /images/favicon-16x16-next.png //16X16小图 medium: /images/favicon-32x32-next.png //32X32大图 apple_touch_icon: /images/apple-touch-icon-next.png //apple-touch-icon safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 实现文章统计功能 安装Hexo插件，参考网站底部字数统计。 编辑主题配置文件，配置如下： # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 效果图： 添加网页顶部进度加载条 编辑主题配置文件，command+F搜索pace，将其值改为ture就可以了，选择一款你喜欢的样式。 # Progress bar in the top during page loading. pace: ture # Themes list: #pace-theme-big-counter #pace-theme-bounce #pace-theme-barber-shop #pace-theme-center-atom #pace-theme-center-circle #pace-theme-center-radar #pace-theme-center-simple #pace-theme-corner-indicator #pace-theme-fill-left #pace-theme-flash #pace-theme-loading-bar #pace-theme-mac-osx #pace-theme-minimal # For example # pace_theme: pace-theme-center-simple pace_theme: pace-theme-minimal 底部隐藏由Hexo强力驱动、主题–NexT.Mist 打开Blog/themes/next/layout/_partials/footer.swig，注释掉相应代码。 //用下面的符号注释，注释代码用下面括号括起来 &lt;!-- --> &lt;!-- &lt;span class="post-meta-divider">|&lt;/span> {% if theme.footer.powered %} &lt;div class="powered-by">{# #}{{ __('footer.powered', '&lt;a class="theme-link" target="_blank" href="https://hexo.io">Hexo&lt;/a>') }}{# #}&lt;/div> {% endif %} {% if theme.footer.powered and theme.footer.theme.enable %} &lt;span class="post-meta-divider">|&lt;/span> {% endif %} {% if theme.footer.theme.enable %} &lt;div class="theme-info">{# #}{{ __('footer.theme') }} &amp;mdash; {# #}&lt;a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">{# #}NexT.{{ theme.scheme }}{# #}&lt;/a>{% if theme.footer.theme.version %} v{{ theme.version }}{% endif %}&lt;/div> {% endif %} {% if theme.footer.custom_text %} &lt;div class="footer-custom">{# #}{{ theme.footer.custom_text }}{# #}&lt;/div> {% endif %} --> &lt;/div> 去掉底部重复字数统计 注释掉如下代码： &lt;!-- {% if theme.post_wordcount.totalcount %} &lt;span class="post-meta-divider">|&lt;/span> &lt;span class="post-meta-item-icon"> &lt;i class="fa fa-area-chart">&lt;/i> &lt;/span> {% if theme.post_wordcount.item_text %} &lt;span class="post-meta-item-text">{{ __('post.totalcount') }}&amp;#58;&lt;/span> {% endif %} &lt;span title="{{ __('post.totalcount') }}">{{ totalcount(site, '0,0.0a') }}&lt;/span> {% endif %} --> 博文置顶 修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 'use strict'; var pagination = require('hexo-pagination'); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } }); }; 文章添加Top值，值越大，越靠前： --- title: Hexo-NexT主题配置 date: 2018-01-20 20:41:08 categories: Hexo tags: - Hexo - NexT top: 100 --- 修改字体大小 编辑Blog/themes/next/source/css/_variables/base.styl，command+F搜索$font-size-base，修改为你想要的大小： // Font size $font-size-base = 16px 添加DaoVoice在线联系 首先到DaoVoice注册账号，登录成过后，进入到后台管理，点击应用设置——&gt;安装到网站查看安装代码和AppID。 将安装代码添加到Blog/themes/next/layout/_partials/head.swig中： {% if theme.daovoice %} &lt;script> (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', { app_id: "{{theme.daovoice_app_id}}" }); daovoice('update'); &lt;/script> {% endif %} 编辑主题配置文件，添加如下代码： # Online contact daovoice: true daovoice_app_id: daovoice_app_id 效果图如下所示： 添加底部桃心 打开Blog/themes/next/layout/_partials/footer.swig搜索with-love，在fontawesom找到你喜欢的图标，在如下位置替换即可： 添加侧栏推荐阅读 编辑主题配置文件，如下配置即可： # Blog rolls links_icon: link links_title: 推荐阅读 #links_layout: block links_layout: inline links: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 在文章底部增加版权信息 在目录Blog/themes/next/layout/_macro/，添加文件 my-copyright.swig，内容如下： {% if page.copyright %} &lt;div class="my_post_copyright"> &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js">&lt;/script> &lt;!-- JS库 sweetalert 可修改路径 --> &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js">&lt;/script> &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js">&lt;/script> &lt;p>&lt;span>本文标题:&lt;/span>&lt;a href="{{ url_for(page.path) }}">{{ page.title }}&lt;/a>&lt;/p> &lt;p>&lt;span>文章作者:&lt;/span>&lt;a href="/" title="访问 {{ theme.author }} 的个人博客">{{ theme.author }}&lt;/a>&lt;/p> &lt;p>&lt;span>发布时间:&lt;/span>{{ page.date.format("YYYY年MM月DD日 - HH:MM") }}&lt;/p> &lt;p>&lt;span>最后更新:&lt;/span>{{ page.updated.format("YYYY年MM月DD日 - HH:MM") }}&lt;/p> &lt;p>&lt;span>原始链接:&lt;/span>&lt;a href="{{ url_for(page.path) }}" title="{{ page.title }}">{{ page.permalink }}&lt;/a> &lt;span class="copy-path" title="点击复制文章链接">&lt;i class="fa fa-clipboard" data-clipboard-text="{{ page.permalink }}" aria-label="复制成功！">&lt;/i>&lt;/span> &lt;/p> &lt;p>&lt;span>许可协议:&lt;/span>&lt;i class="fa fa-creative-commons">&lt;/i> &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际&lt;/a> 转载请保留原文链接及作者。&lt;/p> &lt;/div> &lt;script> var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function(){ clipboard.on('success', function(){ swal({ title: "", text: '复制成功', icon: "success", showConfirmButton: true }); }); }); &lt;/script> {% endif %} 在目录Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码： .my_post_copyright { width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); } .my_post_copyright p{margin:0;} .my_post_copyright span { display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; } .my_post_copyright .raw { margin-left: 1em; width: 5em; } .my_post_copyright a { color: #808080; border-bottom:0; } .my_post_copyright a:hover { color: #a3d2a3; text-decoration: underline; } .my_post_copyright:hover .fa-clipboard { color: #000; } .my_post_copyright .post-url:hover { font-weight: normal; } .my_post_copyright .copy-path { margin-left: 1em; width: 1em; +mobile(){display:none;} } .my_post_copyright .copy-path:hover { color: #808080; cursor: pointer; } 在Blog/themes/next/source/css/_common/components/post/添加文件my-post-copyright.styl，文件内容如下： .my_post_copyright { width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4); } .my_post_copyright p{margin:0;} .my_post_copyright span { display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold; } .my_post_copyright .raw { margin-left: 1em; width: 5em; } .my_post_copyright a { color: #808080; border-bottom:0; } .my_post_copyright a:hover { color: #a3d2a3; text-decoration: underline; } .my_post_copyright:hover .fa-clipboard { color: #000; } .my_post_copyright .post-url:hover { font-weight: normal; } .my_post_copyright .copy-path { margin-left: 1em; width: 1em; +mobile(){display:none;} } .my_post_copyright .copy-path:hover { color: #808080; cursor: pointer; } 修改Blog/themes/next/layout/_macro/post.swig，在如图位置添加以下代码： &lt;div> {% if not is_index %} {% include 'my-copyright.swig' %} {% endif %} &lt;/div> 在Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码： @import "my-post-copyright" 在Markdown文章中加入copyright : ture： --- title: Hexo-NexT主题配置 date: 2018-01-20 20:41:08 categories: Hexo tags: - Hexo - NexT top: 100 copyright: ture --- 配置根目录下的_config.yml文件，配置为： # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: https://wenmobo.github.io/ //你的网站地址 root: / permalink: :year/:month/:day/:title/ permalink_defaults: 效果图如下所示： Hexo博客添加站内搜索 NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装吧。 安装 hexo-generator-search npm install hexo-generator-search --save 安装 hexo-generator-searchdb npm install hexo-generator-searchdb --save 编辑站点配置文件，添加以下内容 search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，设置Local searchenable为ture # Local search # Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: ture # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 效果如下图所示：]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识——CSS3]]></title>
    <url>%2F2019%2F03%2F28%2FCSS3%2F</url>
    <content type="text"><![CDATA[CSS3篇：1.CSS清除浮动的几种方法（至少两种） 使用带clear属性的空元素; 使用CSS的overflow属性； 使用CSS的:after伪元素； 使用邻接元素处理； 2.页面导入样式时，使用link和@import有什么区别？​ link属于HTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而 @import是CSS提供的，只能用于加载CSS; ​ 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; ​ import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识——Webpack]]></title>
    <url>%2F2019%2F03%2F28%2FWebpack%2F</url>
    <content type="text"><![CDATA[Webpack篇：1.Webpack是什么？​ Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源 2.loader的作用：​ 实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js 转换这些文件，从而使其能够被添加到依赖图中 3.优化插件：​ OccurenceOrderPlugin: 为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多 的模块，然后为他们分配最小的ID ​ UglifyJsPlugin: 压缩代码]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识——JavaScript]]></title>
    <url>%2F2019%2F03%2F28%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript篇：1.javascript的typeof返回哪些数据类型?​ string、number、boolean、Ｏbject、underfind、function ; 2.js的数据类型都有哪些？ 字符串、数字、布尔、数组、对象、Null、Undefined、Symbol\ 3.例举3种强制类型转换和2种隐式类型转换?​ 强制类型转换：parseInt,parseFloat,number ​ 隐世类型转换：==和=== 4.数组方法pop() push() unshift() shift()​ Push()尾部添加 pop()尾部删除 ​ Unshift()头部添加 shift()头部删除 5.谈谈This对象的理解。​ this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。 ​ 但是有一个总原则，那就是this指的是调用函数的那个对象。 ​ this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识——HTML5]]></title>
    <url>%2F2019%2F03%2F28%2FHTML5%2F</url>
    <content type="text"><![CDATA[HTML5篇：1.html5有哪些新特性、移除了那些元素？​ 新增的元素有绘画 canvas ，用于媒介回放的 video 和 audio 元素，本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除，此外，还新增了以下的几大类元素。 内容元素: article、footer、header、nav、section 表单控件: calendar、date、time、email、url、search 控件元素: webworker, websockt, Geolocation 移出的元素有下列这些： 显现层元素： basefont，big，center，font, s，strike，tt，u 性能较差元素： frame，frameset，noframes 2.如何处理HTML5新标签的浏览器兼容问题？ 处理兼容问题有两种方式： (1) IE8/IE7/IE6支持通过document.createElement方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。 (2) 最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 3.如何区分 HTML 和HTML5？​ DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构、功能元素来加以区分。 4.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？行内元素有： a b span img input select strong 块级元素有： div ul ol li dl dt dd h1 h2 h3 h4…p 知名的空元素： &lt;br&gt;&lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的是： &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 5.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; ​ 而引用CSS文件的@import就是造成这个问题的罪魁祸首。 ​ IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件， ​ 因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 ​ 解决方法简单的出奇，只要在之间加入一个或者元素就可以了。]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础知识——Web]]></title>
    <url>%2F2019%2F03%2F27%2FWeb%2F</url>
    <content type="text"><![CDATA[Web篇：1.常见的浏览器内核有哪些？ IE：Trident内核 FireFox：gecko内核 Opera ：原是用Presto，现改用Blink Safari ：webkit内核 Chrome：Blink（WebKit的分支） 2.前端页面有哪三层构成，分别是什么?作用是什么?​ 结构层 Html ， 表示层 CSS ， 行为层 js 3.请描述一下 cookies，sessionStorage 和 localStorage 的区别？ sessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。 sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个”浏览器窗口”的概念。sessionStorage是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时”独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的 cookies会发送到服务器端。其余两个不会。 4.ajax的缺点 ajax不支持浏览器back按钮。 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。不容易调试。 5.怎样添加、移除、移动、复制、创建和查找节点。1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性]]></content>
      <categories>
        <category>前端知识</category>
      </categories>
      <tags>
        <tag>Front</tag>
      </tags>
  </entry>
</search>
